#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA) 
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)
.decl return(id_transfer: Transfer, id_block_from: Block)
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

#ifdef ENABLE_INPUT_FROM_FILES
.input function
.input block
.input blockStmt
.input follows
.input argument
.input statement
.input assign
.input const
.input uop
.input bop
.input load
.input structLoad
.input store
.input structStore
.input goto
.input branch
.input return
.input jump
.input transferArgument
.input selfdestruct
.input revert
.input builtinVariable


// -- output relations --
.decl tainted_sinks(id: SSA)

// Useful (wallah)
.decl msgSender(id: SSA)
msgSender(id) :-  builtinVariable(id, "SENDER").
msgSender(id) :-  assign(id, orig), msgSender(orig).

// Transitively close constants. TODO: include as const if it is a bop or uop on constants 
const(id, value) :- assign(id, orig), const(orig, value).
// Transitively close load
load(id, field) :-  assign(id, orig), load(orig, field).

// Helpher function: check if something is (in)directly an argument
.decl user_input(id: SSA)
user_input(id) :- argument(id,_,_).
user_input(id) :- assign(id, orig), user_input(orig).

// Check if something depends on user input or user address (tainted)
.decl depon_user_info(id: SSA)
depon_user_info(id) :- user_input(id); msgSender(id).
depon_user_info(id) :- bop(id, id_lhs, id_rhs, _), (depon_user_info(id_lhs); depon_user_info(id_rhs)).
depon_user_info(id) :- uop(id, id_orig,_), depon_user_info(id_orig).
// Check if something depends on user input
.output depon_user_info

// Check if something depends only on constants
.decl depon_const_info(id: SSA)
depon_const_info(id) :- const(id, _); (const(orig, _), assign(id, orig)).
depon_const_info(id) :- bop(id, id_lhs, id_rhs, _), (depon_const_info(id_lhs); depon_const_info(id_rhs)).
depon_const_info(id) :- uop(id, id_orig, _), depon_const_info(id_orig). 

// Encode each state variable as a one-hot vector
// (assuming there are 3 state variables) 100 for the first variables
// 000 means all state variables are untainted, 100 means only first 
// field, V00, is tainted
.decl activate_taint(state: number, field: Name)

// These inputs are generated/written by Python (found a way to do them in dl)
activate_taint(s, field) :- s = 2^k, k = to_number(substr(field, 1, strlen(field))), store(_, field, _).
//activate_taint(1, "V00").
//activate_taint(2, "V01").
//activate_taint(4, "V02").

.decl field_cnt(cnt:number)
field_cnt(cnt) :- cnt = count:{activate_taint(_,_)}.

.decl deactivate_taint(state: number, field: Name) 
// Unfortunately we only need 3 bits but datalog gives us 32 hence the need for 
// 0b111 mask (i.e. 7)
deactivate_taint(bnot tainted, field) :- activate_taint(tainted, field). 

.type BlkList = [next: BlkList, blk: Block]
//.decl program_run(executed_blks: BlkList, final_state: number, guarded: number) // final state after executing blklist

// Now we make a relation block_taints_state_variable which contains
// records of the form B02, 101 meaning that inside B02 there is a store of user input
// (including msg.sender) to V00 and V02

// blk is the block, tainted_fields are the fields which are assigned user input inside 
// blk, and cnt is the number of tainted variables taken into account by the relation
// TODO (done): a block taints a state variable if it does not store a constant in it (instead of specifying the unsafe, specify the safe -- principle of whitelisting)
// TODO: While this approach whitelisting approach works for simple cases, it does not work in harder cases where the value of one state var is stored in another state var
.decl block_taints_state_variables(blk: Block, tainted_fields: number, cnt : number)
block_taints_state_variables(blk, tainted_fields, 1) :- store(stmt, field, assigned),
  blockStmt(blk, stmt), activate_taint(tainted_fields, field), 
  depon_user_info(assigned). //!const(assigned, _).
  //(!const(assigned, _); (load(assigned, field), activate_taint(tvec, field), block_taints_state_variables(blk,tvec,_))).

// Combine taints for a block
block_taints_state_variables(blk, tainted_fields_first bor tainted_fields_second, cnt1 + cnt2) :- 
  block_taints_state_variables(blk, tainted_fields_first, cnt1),
  block_taints_state_variables(blk, tainted_fields_second, cnt2),
  cnt1+ cnt2 < numfields, field_cnt(numfields). // Again, 3 and 7 should be generated/written by python (done already in dl)

// Unfortunately, at this point we still have a lot of relations for block_taints_state_variable 
// of the form (blk, 110, 2) and (blk, 100, 1) but we only care about the one maximum cnt so we say (souffle 
// does not allow witnesses for maximum so we have to create a new relation)
.decl block_taints_not_complete(blk: Block, tainted_fields: number, cnt: number)
block_taints_not_complete(blk, tainted_fields, cnt) :- block_taints_state_variables(blk, tainted_fields, cnt),
  		block_taints_state_variables(blk, tainted_fields2, cnt2), cnt2 > cnt.
.decl block_taints_complete(blk: Block, tainted_fields: number, cnt: number)

// A block taints (completely) if there is no example where it is a minimum (in terms of cnt).
block_taints_complete(blk, tainted_fields, cnt) :- block(blk), 
  												   block_taints_state_variables(blk, tainted_fields, cnt),
  												  !block_taints_not_complete(blk, tainted_fields, cnt).

.decl block_taints_noth(blk: Block)
block_taints_noth(blk) :- block(blk), !block_taints_complete(blk, _, _).

// *********************** BLOCK CLEANING STATE VARIABLES ****************************

.decl block_removes_taint_sv(blk: Block, cleaned_fields: number, cnt: number)
block_removes_taint_sv(blk, cleaned_fields, 1) :- store(stmt, field, assigned),
      blockStmt(blk, stmt), deactivate_taint(cleaned_fields, field), 
      depon_const_info(assigned).

// Combine taint deactivations for a block
block_removes_taint_sv(blk, cleaned_fields_first band cleaned_fields_second, cnt1 + cnt2) :- 
  block_removes_taint_sv(blk, cleaned_fields_first, cnt1),
  block_removes_taint_sv(blk, cleaned_fields_second, cnt2),
  cnt1+ cnt2 < numfields, field_cnt(numfields). 

.decl block_cleans_not_complete(blk: Block, cleaned_fields: number, cnt: number)
block_cleans_not_complete(blk, cleaned_fields, cnt) :- block_removes_taint_sv(blk, cleaned_fields, cnt),
  		block_removes_taint_sv(blk, cleaned_fields2, cnt2), cnt2 > cnt.
.decl block_removes_taint_complete(blk: Block, cleaned_fields: number, cnt: number)

// A block taints (completely) if there is no example where it is a minimum (in terms of cnt).
block_removes_taint_complete(blk, cleaned_fields, cnt) :- block(blk), 
  												   block_removes_taint_sv(blk, cleaned_fields, cnt),
  												  !block_cleans_not_complete(blk, cleaned_fields, cnt).


// *********************** END BLOCK CLEANING STATE VARIABLES ****************************

// Either const or msg.sender (the safe values in a require)
.decl cnst_or_sender(stmt: SSA)
cnst_or_sender(stmt) :- const(stmt, _); msgSender(stmt).

// we consider a (later guard) condition to be safe if it does not depend on user provided arguments. However, we keep
// track of which state variables it depends on.
.decl safe_condition(stmt: SSA, state_variables: number)
// condition is const op const
safe_condition(stmt, 0) :- bop(stmt, lhs, rhs,_), cnst_or_sender(lhs), cnst_or_sender(rhs).
// load op const
safe_condition(stmt, tvec) :- bop(stmt, lhs, rhs,_), load(lhs, field), cnst_or_sender(rhs), activate_taint(tvec, field).
// const op load
safe_condition(stmt, tvec) :- bop(stmt, lhs, rhs,_), load(rhs, field), cnst_or_sender(lhs), activate_taint(tvec, field).
// load op load
safe_condition(stmt, tvec1 bor tvec2) :- bop(stmt, lhs, rhs,_), load(rhs,field1), 
  											load(lhs,field2), activate_taint(tvec1, field1), activate_taint(tvec2, field2).

// cond op cond
safe_condition(stmt, tvec1 bor tvec2) :- bop(stmt, lhs, rhs,_), safe_condition(rhs,tvec1), 
  											safe_condition(lhs, tvec2).

// cond op const
// const op cond
safe_condition(stmt, tvec) :- bop(stmt, lhs, rhs,_),(
  												(
                                                  safe_condition(rhs, tvec), 
                                                  cnst_or_sender(lhs)
                                                ); 
                                                (
                                                    safe_condition(lhs, tvec), 
                                                    cnst_or_sender(rhs)
                                                )
                                            ).

// cond op load
// load op cond
safe_condition(stmt, tvec1 bor tvec2) :- bop(stmt, lhs, rhs,_),(
  												(
                                                  safe_condition(rhs, tvec1), 
                                                  load(lhs, field2), activate_taint(tvec2, field2)
                                                ); 
                                                (
                                                  safe_condition(lhs, tvec1), 
                                                  load(rhs, field2), activate_taint(tvec2, field2)
                                                )
                                            ).
// TODO: take into account argument transfers (see example 8)                                   
// Same as safe_condition but we only care about those which produce a branching
.decl safe_guard_condition(stmt: SSA, state_variables: number)
safe_guard_condition(stmt, state_variables) :- safe_condition(stmt, state_variables), branch(_,_, _,_,_, stmt).

// TODO: take into account argument transfers (see example 8)  
.decl safe_guarded_block(blk: Block, state_variables: number)
safe_guarded_block(blk, state_variables) :- safe_guard_condition(stmt, state_variables), blockStmt(blk,stmt).

.decl unguarded_block(blk: Block)
unguarded_block(blk) :- block(blk), !safe_guarded_block(blk, _).

// Simulate program run
// final_state is the state of all state variables at end of execution

// ********************* PROGRAM LOGIC *********************
/* After executing executed_blks, we now execute current_block. We now do a case-by-case study depending on 
 * two factors: whether there is a guard after execution of executed_blks, and whether the current block contains a guard
 *
 * CASE 1 (Guard in executed_blks): regardless of what current_blk is, the execution is still guarded (of course, it
 * is still possible that there is a execution flow which ends in current_blk and is unguarded. (Relation program_run 
 * merely expresses the state after a sequence of blocks, not the absolute state of a single block).
*/
.decl program_run(executed_blks: BlkList, final_state: number, guarded: number, hist_size: number, string_hist: symbol) // final state after executing blklist

// Now make sure every other function block (apart from constructor) follows from constructor
//.decl blockFollows(id_block_from: Block, id_block_to: Block)
// There is a follows relation b/w blocks in case of 1: goto 2: branch 3: jump 
//blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, id_block_to).
//blockFollows(id_block_from, id_block_to) :-  branch(_, _, id_block_from, id_block_to, _, _); 
//                                             branch(_, _, id_block_from, _, id_block_to, _).
//blockFollows(id_block_from, id_block_to) :- jump(_,id_block_from, id_block_to,_); 
//                                            jump(_,_,id_block_from, id_block_to). 
// ******************** NEW ******************** 
// a long block is a block with more than one store
.decl longBlock(longblk: Block)
longBlock(blk) :- store(id1, _, _), blockStmt(blk, id1), store(id2, _, _), blockStmt(blk, id2), id1 != id2. 


.decl store_block_follows(from_stmt: number, to_stmt: number, parent: Block)
store_block_follows(from, to, parent) :- store_block(_, parent, from), store_block(_, parent, to), from < to.

.decl not_follows_immediately(from: number, to: number, parent: Block)
not_follows_immediately(from, to, parent) :- not_follows_immediately(from, mid, parent), 
  not_follows_immediately(mid, to, parent), mid < to, mid > from.

// connect all the individual store blocks together
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, parent, sid_from),
  store_block(id_block_to, parent, sid_to), !not_follows_immediately(sid_from, sid_to, parent).

.decl not_first_store(sblk: Block, sid: number, parent: Block)
not_first_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(sblk2, parent, sid2), sid2 < sid.

.decl not_last_store(sblk: Block, sid: number, parent: Block)
not_last_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(sblk2, parent, sid2), sid2 > sid.


.decl store_block(store_block: Block, parent_block: Block, stmt_order: number)
block(sblk), blockStmt(sblk, stmt), store_block(sblk, parent, order) :- 
  store(stmt, _, _), blockStmt(parent, stmt), sblk = cat(parent, stmt), 
  order = to_number(substr(stmt, 1, strlen(stmt))), longBlock(parent).   


// Now make sure every other function block (apart from constructor) follows from constructor
.decl blockFollows(id_block_from: Block, id_block_to: Block)

// from the last store of a multistore block to the parent block (which we segmented into multiple stores)
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, id_block_to, _), 
  											!not_last_store(id_block_from, _, id_block_to).
  											
// There is a follows relation b/w blocks in case of 1: goto 2: branch 3: jump 
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, id_block_to), !longBlock(id_block_to).

// If it is a multistore block, go to the first store block instead
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, parent), longBlock(parent), 
  											!not_first_store(id_block_to, _, parent), store_block(id_block_to, _, _).
// Branch without multistore blocks
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, id_block_to, _, _); 
                                             branch(_, _, id_block_from, _, id_block_to, _)), !longBlock(id_block_to).

// Branch with multistore blocks (same as before: go to the first store block)
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, parent, _, _); 
                                             branch(_, _, id_block_from, _, parent, _)), 
  											longBlock(parent), !not_first_store(id_block_to, _, parent), 
                                              store_block(id_block_to, _, _).

// Jump without multistore blocks
blockFollows(id_block_from, id_block_to) :- (jump(_,id_block_from, id_block_to,_); 
                                            jump(_,_,id_block_from, id_block_to)), !longBlock(id_block_to). 

// Jump with multistore blocks
blockFollows(id_block_from, id_block_to) :- (jump(_,id_block_from, parent,_); 
                                            jump(_,_,id_block_from, parent)), longBlock(parent),
  											!not_first_store(id_block_to, _, parent), 
                                              store_block(id_block_to, _, _).

// ******************** END NEW ********************

// base case
program_run([nil, constructor_block], 0, 0, 1, constructor_block) :- function(constructor_block, "Constructor").

// From the constructor, every start of a function follows
//blockFollows("Constructor", fct_blk) :- function(fct_blk,x), x!="Constructor".
blockFollows(conblk, fct_blk) :- function(fct_blk,x), function(conblk, "Constructor"), x!="Constructor".

.decl terminating_ret(blk: Block)
terminating_ret(blk) :- (return(_, blk); revert(_,blk)), !jump(_, _, blk, _).

blockFollows(termblk, fctblk) :- terminating_ret(termblk), function(fctblk, fctname), fctname!="Constructor".
// If the flow so far is unguarded and the next (current) block is unguarded or has a guard which
// depends on tainted state variables then the next state is unguarded. If the current block taints 
// some state variables then we maintain these taints in the next state. Otherwise, we leave the taints as they are.
program_run([executed_blks, current_blk], tainted_fields bor curr_tainted, 0, hs+1, currhist)  :- 
  program_run(executed_blks, tainted_fields, 0, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk],
  			(
  				(!block_taints_complete(current_blk, _, _), curr_tainted = 0);
  				block_taints_complete(current_blk, curr_tainted, _)
			  )
			,(
              	unguarded_block(current_blk);
               (safe_guarded_block(blk, sv), sv band (tainted_fields bor curr_tainted) != 0)
        ).

// If a program cleans a state variable
program_run([executed_blks, current_blk], tainted_fields band curr_cleaned, 0, hs+1, currhist)  :- 
  program_run(executed_blks, tainted_fields, 0, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk],
  			(
  				(!block_removes_taint_complete(current_blk, _, _), curr_cleaned = 0);
  				block_removes_taint_complete(current_blk, curr_cleaned, _)
			  )
			,(
              	unguarded_block(current_blk);
               (safe_guarded_block(blk, sv), sv band (tainted_fields band curr_cleaned) != 0)
        ).

// Guarded flow remains guarded until it terminates
program_run([executed_blks, current_blk], tainted_fields, 1, hs+1, currhist) :- 
  program_run(executed_blks, tainted_fields, 1, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], !terminating_ret(current_blk).
 
// Here, the guarded flow terminates
program_run([executed_blks, current_blk], tainted_fields, 2, hs+1, currhist) :- 
  program_run(executed_blks, tainted_fields, 1, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], terminating_ret(current_blk).
  			
// Guarded flow from an unguarded flow if there is a guard
program_run([executed_blks, current_blk], tainted_fields, 1, hs+1, currhist) :- 
  program_run(executed_blks, tainted_fields, 0, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], 
  			(
  				(!block_taints_complete(current_blk, _, _), curr_tainted = 0);
  				block_taints_complete(current_blk, curr_tainted, _)
			  ), safe_guarded_block(blk, sv), sv band (tainted_fields bor curr_tainted) = 0.

.decl debugInfo(executed_blks: BlkList, tfields: number, currhist: symbol)

tainted_sinks(stmt), debugInfo(executed_blks, tainted_fields, currhist):-
  			selfdestruct(stmt, addr), blockStmt(current_blk, stmt),
  			program_run(executed_blks, tainted_fields, 0, _, currhist), block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], 
  			(
  				(!block_taints_complete(current_blk, _, _), curr_tainted = 0);
  				block_taints_complete(current_blk, curr_tainted, _)
			  )
		    ,(msgSender(addr); // addr of self destruct is msgsender, a tainted field, or is a bop which depends on user input (e.g. A01)
            	(
              		activate_taint(s, field), load(addr, field), s band (curr_tainted bor tainted_fields) != 0
				      );          
                (bop(stmt, _, _, _), !safe_condition(addr, _))
         ).

//tainted_sinks(id) :- selfdestruct(id, _).

.output program_run
.output deactivate_taint
.output tainted_sinks
.output debugInfo
/*.output blockDominates
.output blockFollows
.output blockFollowsTransitive
.output notDominates
.output hasGuardSSA
.output unguardedTaintedSSA
.output guardSSA
.output taintedSSA
.output taintedStorage
.output context
.output fields
*/