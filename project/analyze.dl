#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA) 
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)
.decl return(id_transfer: Transfer, id_block_from: Block)
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

#ifdef ENABLE_INPUT_FROM_FILES
.input function
.input block
.input blockStmt
.input follows
.input argument
.input statement
.input assign
.input const
.input uop
.input bop
.input load
.input structLoad
.input store
.input structStore
.input goto
.input branch
.input return
.input jump
.input transferArgument
.input selfdestruct
.input revert
.input builtinVariable


// -- output relations --
.decl tainted_sinks(id: SSA)


// Useful (wallah)
.decl msgSender(id: SSA)
msgSender(id) :-  builtinVariable(id, "SENDER").
msgSender(id) :-  assign(id, orig), msgSender(orig).
msgSender(id) :-  uop(id, orig, _), msgSender(orig).

// Transitively close constants. TODO: include as const if it is a bop or uop on constants 
const(id, value) :- assign(id, orig), const(orig, value).
const(id, value) :- uop(id, orig, _), const(orig, value).

// Transitively close load
load(id, field) :-  assign(id, orig), load(orig, field).
load(id, field) :-  uop(id, orig, _), load(orig, field).

// Helper function: check if something depends on an argument
.decl user_input(id: SSA, depends_on_arg: SSA)
user_input(id, id) :- argument(id,_,_).
user_input(id, arg) :- assign(id, orig), user_input(orig, arg).
user_input(id, arg) :- uop(id, orig, _), user_input(orig, arg).

// Given that arguments are used only once we can treat similarly to fields. A01 -> 0013, A00 -> 0001, A02 
.decl arg_bv(state: number, id_arg: SSA)
arg_bv(s, id) :- s = 2^k, k = to_number(substr(id, 1, strlen(id))), argument(id, _, _).

.decl arg_cnt(cnt:number)
arg_cnt(cnt) :- cnt = count:{arg_bv(_,_)}.

// Check if something depends only on constants
.decl depon_const_info(id: SSA)
depon_const_info(id) :- const(id, _); (assign(id, orig), depon_const_info(orig)).
depon_const_info(id) :- bop(id, id_lhs, id_rhs, _), depon_const_info(id_lhs), depon_const_info(id_rhs).
depon_const_info(id) :- uop(id, id_orig, _), depon_const_info(id_orig).  

.decl ssa_depens_complete(stmt: SSA, args: number, sv: number, sndr: number, cnt: number) // the things an SSA depends on
// Base cases
ssa_depens_complete(id, 0, 0, 0, 0) :- depon_const_info(id).
ssa_depens_complete(id, s, 0, 0, 1) :- user_input(id, arg), arg_bv(s, arg). // (id, s, 0 , 0, 1)  id_var = id 
ssa_depens_complete(id, 0, s, 0, 1) :- load(id, field), sv_bv(s, field).
ssa_depens_complete(id, 0, 0, 1, 0) :- msgSender(id).

//.output ssa_depens_complete

// Tree recursion
ssa_depens_complete(id, args, sv, sndr, cnt)  :- (assign(id, orig); uop(id, orig, _)), ssa_depens_complete(orig, args, sv, sndr, cnt).
ssa_depens_complete(id, args_lhs bor args_rhs, sv_lhs bor sv_rhs, sndr_lhs bor sndr_rhs, cnt_lhs + cnt_rhs)  :- bop(id, id_lhs, id_rhs, _), 
                  ssa_depens_complete(id_lhs, args_lhs, sv_lhs, sndr_lhs, cnt_lhs),  
                  ssa_depens_complete(id_rhs, args_rhs, sv_rhs, sndr_rhs, cnt_rhs). 
                  // and operation is to ensure no var is taken into account more than once

/// ********************* Start: Store context in block *********************
.decl sv_bv(state: number, field: Name)

// For state variable taint activation
sv_bv(s, field) :- s = 2^k, k = to_number(substr(field, 1, strlen(field))), store(_, field, _). // one-hot encoding

.type BlkList = [next: BlkList, blk: Block]

// Context of store in a block // B00, S02, 013, 013, 1
.decl block_modifies_sv(blk: Block, sv: Name, state_dependency: number, arg_dependency: number, sndr: number)
block_modifies_sv(blk, field, state_dep, arg_dep, sndr_dep) :- store(stmt, field, assigned), !longBlock(blk),
  blockStmt(blk, stmt), ssa_depens_complete(assigned, arg_dep, state_dep, sndr_dep, _). 

/// ********************* END: Store context in block *********************

// We consider a (later guard) condition to be safe if it does not depend on user provided arguments. However, we keep
// track of which state variables and which arguments it depends on.
//.decl safe_condition(stmt: SSA, state_dependency: number, arg_dependency: number, sndr_dep : number)  

// (Potentially) safe condition with dependency on state variables

.decl conditioned_block(blk: Block, state_dependency: number, arg_dependency: number, sndr_dep: number)
// sndr_dep being 0 means that the safe condition can potentially be safe if one of the arguments depends on sndr (and other values it depends on are clean)
// sndr_dep being 1 means that the safe condition explicitly depends on msg.sender via an S-type SSA.
conditioned_block(blk, state_dependency, arg_dependency, sd) :- ssa_depens_complete(stmt, arg_dependency, state_dependency, sd, _), branch(_,_, blk,_,_, stmt).// blockStmt(blk,stmt). block with safe guard condition need not have the var_cond defined inside the block (example: T0:: A02)
//conditioned_block(blk, state_dependency, arg_dependency, 1) :- ssa_depens_complete(stmt, arg_dependency, state_dependency, 1, _), branch(_,_, blk,_,_, stmt).

.decl unconditioned_block(blk: Block)
// Captures blocks which are not guarded (as in those that do have a condition that does NOT depend on msg.sender, and also those that do not have a condition alas)
unconditioned_block(blk) :- block(blk), !branch(_, _, blk, _, _, _). // !conditioned_block(blk, _, _). // NB: a block can also be "unguarded" if some of its dependencies become tainted

// Conditioned but not guarded (i.e. has branch which has no dependence on msg.sender)
//.decl unguarded_block(blk: Block, args: number, sv: number)
//unguarded_block(blk, args, sv) :- branch(_, _, blk, _, _, stmt), ssa_depens_complete(stmt, args, sv, 0, _).

// ***************** argument transfer *****************
.decl blockFollowsClosed(start: Block, fin: Block)
blockFollowsClosed(start, fin) :- blockFollows(start, fin).
blockFollowsClosed(start, fin) :- blockFollows(start, mid), blockFollowsClosed(mid, fin).


.decl returnFromBlock(srcblk: Block, sinkblk: Block)
returnFromBlock(start, fin) :- blockFollowsClosed(start, fin), return(_, fin).
// Imagine the chain B00-J->B01...-R->B02 encoded as jump(_, B00, B01, B02)  then B02-J->B03..-R->B04 and then finally B04 returns to the function which called B00 
// in this case, returnFromBlock should have the pair B00, B04. Here is how to do this transitively

// Base case
returnFromBlock(start, fin) :- jump(_, start,_,fin), return(_, fin).
// Recurse
returnFromBlock(start, fin) :- jump(_, start,_,cont), returnFromBlock(cont, fin).

.decl arg_flow(arg: SSA, id_val: SSA, idx: number, block_from: Block, block_to: Block)
arg_flow(arg, id_val, idx, block_from, block_to) :- transferArgument(transfer, id_val, idx), 
                                                    (
                                                      goto(transfer, block_from, block_to);
                                                      jump(transfer, block_from, block_to, _);
                                                      (jump(transfer_orig, _, block_from, block_to), return(transfer, block_from)); // when the called function is done
                                                      (jump(transfer_orig, _, block_from_upstream, block_to), returnFromBlock(block_from_upstream,  block_from), return(transfer, block_from))
                                                      // does not seem to be case that a branch transfers any arguments (tho I might be wrong)
                                                    ), argument(arg, block_to, idx), !longBlock(block_to).

arg_flow(arg, id_val, idx, block_from, block_to) :- transferArgument(transfer, id_val, idx), 
                                                    (
                                                      goto(transfer, block_from, parent);
                                                      jump(transfer, block_from, parent, _);
                                                      (jump(transfer_orig, _, block_from, parent), return(transfer, block_from)); // when the called function is done
                                                      (jump(transfer_orig, _, block_from_upstream, parent), returnFromBlock(block_from_upstream, block_from), return(transfer, block_from))
                                                      // does not seem to be case that a branch transfers any arguments (tho I might be wrong)
                                                    ), argument(arg, parent, idx), first_mini_blk(parent, block_to), longBlock(parent).

.decl num_args_interim(block_from: Block, block_to: Block, order: number, cnt: number)
num_args_interim(block_from, block_to, idx, 1) :- arg_flow(_, _, idx, block_from, block_to). // Souffle's cancerous witness problem prevents using a simple count functor

// unique way to construct num_args, namely by adding new arguments only in immediately consecutive order
num_args_interim(block_from, block_to, next_idx, cnt+1) :- num_args_interim(block_from, block_to, idx, cnt), arg_flow(_, _, next_idx, block_from, block_to), next_idx = idx+1.

.decl num_args_non_final(block_from: Block, block_to: Block, order: number, cnt: number)
num_args_non_final(block_from, block_to, order, cnt) :- num_args_interim(block_from, block_to, order, cnt), num_args_interim(block_from, block_to, order2, cnt2), cnt < cnt2.  

.decl num_args(block_from: Block, block_to: Block, cnt: number)
num_args(block_from, block_to, cnt) :- num_args_interim(block_from, block_to, idx, cnt), !num_args_non_final(block_from, block_to, idx, cnt).
num_args(block_from, block_to, 0) :- blockFollows(block_from, block_to), !hasArg(block_to).
num_args(block_from, block_to, 0) :- blockFollows(block_from, block_to), longBlock(block_to).

// argument setupblock 
num_args_interim(block_from, block_to, idx, 1) :- arg_setup_blk(block_from), 
            ((!longBlock(possible_parent), block_to = possible_parent);(first_mini_blk(possible_parent, block_to))), 
            possible_parent = substr(block_from, 3, strlen(block_from)), 
            argument(arg, possible_parent, idx).

num_args_interim(block_from, block_to, idx, cnt+1) :- num_args_interim(block_from, block_to, last, cnt), idx =last+1, arg_setup_blk(block_from),
    ((!longBlock(possible_parent), block_to = possible_parent);(first_mini_blk(possible_parent, block_to))), 
            possible_parent = substr(block_from, 3, strlen(block_from)), 
            argument(arg, possible_parent, idx).

// ***************** end: argument transfer *****************
.decl longBlock(longblk: Block)
longBlock(blk) :- store(id1, _, _), blockStmt(blk, id1), store(id2, _, _), blockStmt(blk, id2), id1 != id2, !function(blk,"Constructor"). 

.decl first_mini_blk(longblk: Block, entrypoint: Block)
first_mini_blk(longblk, entrypoint) :- longBlock(longblk), !not_first_store(entrypoint, _, longblk), store_block(entrypoint, longblk, _). 

.decl store_block_follows(from_stmt: number, to_stmt: number, parent: Block)
store_block_follows(from, to, parent) :- store_block(_, parent, from), store_block(_, parent, to), from < to.

.decl not_follows_immediately(from: number, to: number, parent: Block)
not_follows_immediately(from, to, parent) :- not_follows_immediately(from, mid, parent), 
  not_follows_immediately(mid, to, parent), mid < to, mid > from.

// connect all the individual store blocks together
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, parent, sid_from),
  store_block(id_block_to, parent, sid_to), sid_from < sid_to, !not_follows_immediately(sid_from, sid_to, parent).

.decl not_first_store(sblk: Block, sid: number, parent: Block)
not_first_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(_, parent, sid2), sid2 < sid.

.decl not_last_store(sblk: Block, sid: number, parent: Block)
not_last_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(_, parent, sid2), sid2 > sid.


.decl store_block(store_block: Block, parent_block: Block, stmt_order: number)
block(sblk), blockStmt(sblk, stmt), store_block(sblk, parent, order) :- 
  store(stmt, _, _), blockStmt(parent, stmt), sblk = cat(parent, stmt),
  order = to_number(substr(stmt, 1, strlen(stmt))), longBlock(parent).   


// Now make sure every other function block (apart from constructor) follows from constructor
.decl blockFollows(id_block_from: Block, id_block_to: Block)

// from the last store of a parent block to the parent block itself (which we segmented into multiple stores)
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, id_block_to, _), 
  											!not_last_store(id_block_from, _, id_block_to).
  											
// There is a follows relation b/w blocks in case of 1: goto 2: branch 3: jump 
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, id_block_to), !longBlock(id_block_to).

// If it is a multistore block, go to the first store block instead
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, parent), longBlock(parent), 
  											!not_first_store(id_block_to, _, parent), store_block(id_block_to, _, _).
// Branch without multistore blocks
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, id_block_to, _, _); 
                                             branch(_, _, id_block_from, _, id_block_to, _)), !longBlock(id_block_to).

// Branch with multistore blocks (same as before: go to the first store block)
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, parent, _, _); 
                                             branch(_, _, id_block_from, _, parent, _)), 
  											longBlock(parent), !not_first_store(id_block_to, _, parent), 
                                              store_block(id_block_to, _, _).


// From the constructor, every start of a function follows
// Before the execution of the user-called function there is a helper block which helps sets up the taint for the input supplied by the user
.decl arg_setup_blk(blk: Block)
arg_setup_blk(blk), block(blk) :- blk = cat(con_blk, f_blk), function(con_blk, "Constructor"), function(f_blk, fname), fname != "Constructor".
blockFollows(conblk, setup_blk) :- arg_setup_blk(setup_blk), fblk = substr(setup_blk, 3, strlen(setup_blk)), function(conblk, "Constructor").
blockFollows(setup_blk, fblk) :-  arg_setup_blk(setup_blk), !longBlock(fblk), fblk = substr(setup_blk, 3, strlen(setup_blk)).
blockFollows(setup_blk, sblk) :-  arg_setup_blk(setup_blk), longBlock(fblk), fblk = substr(setup_blk, 3, strlen(setup_blk)), store_block(sblk, fblk, _), !not_first_store(sblk, _, fblk).
//.output blockFollows


// At the end of execution of executed_blks, sv_state determines the state variables which are tainted (have bit set to one),
// arg_state determines the arguments which are tainted (have bit set to one), guarded determines whether it is guarded (by the end of execution of executed_blks)
// string hist is B00B01
.decl program_run(executed_blks: BlkList, sv_state: number, arg_state: number, guarded: number, arg_stack: number, args_sndr: number, implicit_taint: number,  imp_block: Block, hist_size: number, stack: BlkList, string_hist: symbol) // final state after executing blklist
// base case
program_run([nil, constructor_block], 0, 0, 0, -1, 0, 0, "",1, nil, "C") :- function(constructor_block, "Constructor").

//.output arg_flow
.decl hasArg(blk: Block)
hasArg(blk) :- argument(_, blk, _).

.decl doesModify(blk: Block)
doesModify(blk) :- block_modifies_sv(blk, _, _, _, _). 

// ******************** BRANCH FLOW ANALYSIS ***********************
.decl leaf_node(x: Block)
leaf_node(x) :- return(_, x); revert(_, x).

// TODO: include jump(a, b, cont) -> blockFollow(a, cont)
.decl doesNotPassThru(a: Block, b: Block)   // direct children of A do not converge onto B or do not have a leaf node at B
doesNotPassThru(a, b) :- blockFollows(a,c), blockFollows(a,b), c != b, !leaf_node(b), !leaf_node(c).
doesNotPassThru(a, c):- block(a), block(c), !blockFollowsClosed(a, c), a!=c, !leaf_node(c), !leaf_node(a).
doesNotPassThru(a, c) :- blockFollows(a,b),  doesNotPassThru(b, c), a!=c.
.decl mustPassThru(a: Block, b: Block) // signifies that the direct children of A must either pass through B or will be terminated at a leaf, B, of A 
mustPassThru(a, b):- branch(_, _, a, _, _, _), !doesNotPassThru(a, b), blockFollowsClosed(a,b), a!=b.
//mustPassThru("", ""). // sentinel block

// ****************** PROGRAM RUN STATE MACHINE ******************

// State 0: unguarded -  00
// State 1: antiguarded - 01
// State 2: privileged user (has untainted user input, but can act as a confused deputy-- see 13.sol) - 13
// State 3: privileged user running in antiguarded state (i.e. first bit determines whether we are in anti-guarded state or not. - 13
// Make sure to remove anti-guarded state on return (i.e. branch dependency finishes) 

// *********************** START: Normal ctrl flow (i.e. any ctrl flow other than JMP) *************************

// If we are currently at the argument setup block (for user defined input)  -- removed tainting new record's arguments, see the bottom-most rule
program_run([executed_blks, to_blk], sv_taint, args_tainted, 0, -1, args_sndr, imp_taint, imp_blk, hs+1, stack, currhist) :-  
        program_run(executed_blks, sv_taint, args_tainted, 0, -1, args_sndr, imp_taint, imp_blk, hs, stack, prehist),
        blockFollows(last_exec_blk, to_blk), arg_setup_blk(to_blk), // guaranteed to be following from constructor (only where we can reach arg_setup_blk is via constructor) 
        executed_blks = [ancient_list, last_exec_blk],
        //currhist = cat(prehist, cat("->",substr(to_blk, 3, strlen(to_blk)))).
        currhist = cat(cat(prehist, ","), to_blk).

// Handle argument taint transfer (ungarded)
program_run(executed_blks, sv_tainted, final_arg_state, state, idx, final_args_sndr, imp_taint, imp_blk, hs, stack, prehist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk),
        arg_flow(arg, id_val, idx, last_blk, to_blk), idx = last_arg+1, // push arguments in increasing order
        ssa_depens_complete(id_val, args_val, sv_val, sndr_val, cnt_val), 
        // NEW: if you look at the graph of twelve-one.sol A01 is tainted b/c depended impl. on tainted value
        // The reason twelve-one.sol was passing thus far, was b/c our state machine treated the argument A01 as tainted for a reason I still need to figure out
        // If we are transferring a value from an antiguarded state, we propagate the taint on the argument we are transferring
        sndr_dep_complete = sndr_val bor (args_val band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
        safe_sndr = -state/2, // wil be 0b1...1 if state > 1 i.e. privileged        
        sndr_val_comp = sndr_dep_complete band (bnot safe_sndr),
        arg_taint_dep = args_val band (args_tainted band (bnot args_sndr)),
        sv_taint_dep = sv_val band sv_tainted, 
        is_imp_tainted = -1*(state band 1),
        non_sndr_taint = arg_taint_dep bor sv_taint_dep bor is_imp_tainted, // since we remain here inside the context of the if statement, consts are still clean (see twelve)
        is_id_val_taint = non_sndr_taint bor sndr_val_comp, // sndr_val_comp is equiv. to sndr_dep_complete only if untrusted senter
        (
            (is_id_val_taint != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted);
            (is_id_val_taint = 0, arg_bv(bv, arg), final_arg_state = (bnot bv) band args_tainted)  // 24.sol sometimes an argument needs to be cleaned b/c same function is called again with clean variable
        ),
        (   // notice that unlike the is_id_val_taint here, sndr_dep_complete since we want to know if there is a dependency regardless whether msg sender is trusted or not
            (non_sndr_taint = 0, sndr_dep_complete != 0,  arg_bv(bv, arg), final_args_sndr = bv bor args_sndr); // if the only taint comes from the sndr, then include it in the bit vector
            ((non_sndr_taint != 0; sndr_dep_complete = 0),  arg_bv(bv, arg), final_args_sndr = (bnot bv) band args_sndr) // o/w remove it from args_sndr flag if there is non-sndr taint or no dependence on sndr
        ),
        hs < 13.
//.output arg_flow
//.output num_args

// Handle state variable taint transfer (ungarded). New: checks first there is NO guard inside last_blk to know if we can still remain in unguarded state 

// Case 0: unguarded non-privileged user
program_run([executed_blks, to_blk], final_state, args_tainted, state_end, -1, args_sndr, final_imp_taint, final_imp_blk, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 0, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),
                sndr_val = sndr_dep bor (arg_dep band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,
                sv_bv(bv, field),
                (
                    (is_sv_val_taint != 0, final_state = bv bor sv_tainted);
                    (is_sv_val_taint = 0, final_state = (bnot bv) band sv_tainted)
                ),
                (
                    (state_end = 1, final_imp_taint = bv bor imp_taint); // if to_blk is in the anti-guarded state, then apply implicit taint 
                    (state_end = 0, final_imp_taint = 0)  // o/w don't
                )
            );
            (
                // Since we were at state 0, no matter whether we transitioned to state 1 or 0 again, then the implicit taint will remain 0 under lack of modifications 
                !doesModify(to_blk), final_state = sv_tainted, final_imp_taint = 0
            )
        ), 
        (
            (unconditioned_block(last_blk), state_end = 0, final_imp_blk = imp_blk);
            (   
                conditioned_block(last_blk, guard_sv_dep, guard_arg_dep, guard_sndr_dep),
                (
                    guard_sndr_dep_comp = guard_sndr_dep bor (args_sndr band guard_arg_dep),
                    args_tainted_cond = guard_arg_dep band args_tainted, 
                    sv_tainted_cond   =  guard_sv_dep band sv_tainted,
                    is_tainted = (args_tainted_cond band (bnot args_sndr)) bor sv_tainted_cond, // For conditionals, we examine taint coming only from non-sndr sources? 
                    (   
                        (is_tainted = 0, guard_sndr_dep_comp = 0, state_end = 0, final_imp_blk = ""); // no taint then continue onto normal unguarded state 
                        (is_tainted != 0, state_end = 1, final_imp_blk = last_blk) // o/w continue to antiguarded state
                    )
                )
            )
        ),
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 13.

// Case 1.1: antiguarded unprivileged state 
// This case happens if we are currently in the anti-guarded state and then encounter the end of the ctrl flow induced by the tainted if-condition.
// Since we are in the unprivileged state, we need to make sure there is no guard 
program_run([executed_blks, to_blk], final_state, args_tainted, state_end, -1, args_sndr, final_imp_taint, final_imp_blk, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 1, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        // If the next block is a convergence node (not leaf node, i.e. return or revert) for the tainted if condition, then we exit the tainted state
        // and we transfer the lightly tainted arguments over to the to_blk's  (not lightly) tainted arguments
        mustPassThru(imp_blk, to_blk), //!(return(_, to_blk); revert(_, to_blk)), 
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),
                sndr_val = sndr_dep bor (arg_dep band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,
                sv_bv(bv, field), 
                (   
                    (is_sv_val_taint != 0, final_state = (bv bor sv_tainted) bor imp_taint); // if we are exiting the antiguard, we apply the implicit taint to the final state
                    (is_sv_val_taint = 0, final_state = (bnot bv) band (sv_tainted bor imp_taint)) // we give priority to cleaning for precision as it is done after the implicit taint
                )
            );
            (
                !doesModify(to_blk), final_state = sv_tainted bor imp_taint
            )
        ), 
        (
            // As we are moving to a node of convergence (of all tainted if branches), the state will be normal again and the imp_taint vars will all be reset
            final_imp_taint = 0, final_imp_blk = "", state_end = 0
        ),
        (
            // Make sure there is no guard at last_blk preventing ctrl-flow from passing to the to_blk
            unconditioned_block(last_blk);
            (   
                conditioned_block(last_blk, guard_sv_dep, guard_arg_dep, guard_sndr_dep),
                (
                    guard_sndr_dep_comp = guard_sndr_dep bor (args_sndr band guard_arg_dep), 
                    args_tainted_cond = guard_arg_dep band args_tainted, 
                    sv_tainted_cond   =  guard_sv_dep band sv_tainted,
                    is_tainted = (args_tainted_cond band (bnot args_sndr)) bor sv_tainted_cond, // For conditionals, we examine taint coming only from non-sndr sources? 
                    (is_tainted != 0; guard_sndr_dep_comp = 0) // To not be a guard, either there is NO dep. on sndr or there is a taint from non-sndr sources
                )
            )
        ),
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 13.


// Case 1.2: antiguarded unprivileged state 
// This case happens if we are currently in the anti-guarded state but do NOT encounter the end of the ctrl flow induced by the tainted if-condition 
program_run([executed_blks, to_blk], final_state, args_tainted, 1, -1, args_sndr, final_imp_taint, imp_blk, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 1, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        // If the next block is a convergence node (not leaf node, i.e. return or revert) for the tainted if condition, then we exit the tainted state
        // and we transfer the lightly tainted arguments over to the to_blk's  (not lightly) tainted arguments
        !mustPassThru(imp_blk, to_blk), 
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),
                sndr_val = sndr_dep bor (arg_dep band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,
                sv_bv(bv, field), 
                (   
                    (is_sv_val_taint != 0, final_state = bv bor sv_tainted); // if we are exiting the antiguard, we apply the implicit taint to the final state
                    (is_sv_val_taint = 0, final_state = (bnot bv) band sv_tainted) // we give priority to cleaning for precision as it is done after the implicit taint
                ),
                // Since the to_blk happens to be in the tainted ctrl-flow we add the implicit taint on it
                final_imp_taint = imp_taint bor bv
            );
            (
                !doesModify(to_blk), final_state = sv_tainted, final_imp_taint = imp_taint
            )
        ), 
        (
            // Make sure there is no guard at last_blk preventing ctrl-flow from passing to the to_blk
            unconditioned_block(last_blk);
            (   
                conditioned_block(last_blk, guard_sv_dep, guard_arg_dep, guard_sndr_dep),
                (
                    guard_sndr_dep_comp = guard_sndr_dep bor (args_sndr band guard_arg_dep), 
                    args_tainted_cond = guard_arg_dep band args_tainted, 
                    sv_tainted_cond   =  guard_sv_dep band sv_tainted,
                    is_tainted = (args_tainted_cond band (bnot args_sndr)) bor sv_tainted_cond, // For conditionals, we examine taint coming only from non-sndr sources? 
                    (is_tainted != 0; guard_sndr_dep_comp = 0) // To not be a guard, either there is NO dep. on sndr or there is a taint from non-sndr sources
                )
            )
        ),
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 13.


// Case 2: privileged user (no antiguard)
program_run([executed_blks, to_blk], final_state, args_tainted, state_end, -1, args_sndr, final_imp_taint, final_imp_blk,  hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 2, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                // notice sndr is not considered a taint
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep),
                sv_bv(bv, field),
                (
                    (is_sv_val_taint != 0, final_state = bv bor sv_tainted);
                    (is_sv_val_taint = 0, final_state = (bnot bv) band sv_tainted)
                ),
                (
                    (state_end = 3, final_imp_taint = bv bor imp_taint); // if to_blk is in the anti-guarded state, then apply implicit taint 
                    (state_end = 2, final_imp_taint = 0)  // o/w don't
                )
            );
            (
                // if we don't modify anything, then we tainted sv's as they are. Since we are also coming from a privileged state we can reset implicit taint to 0 
                !doesModify(to_blk), final_state = sv_tainted, final_imp_taint = 0
            )
        ), 
        (
            (unconditioned_block(last_blk), state_end = 0, final_imp_blk = imp_blk);
            (   
                conditioned_block(last_blk, guard_sv_dep, guard_arg_dep, guard_sndr_dep),
                (
                    guard_sndr_dep_comp = guard_sndr_dep bor (args_sndr band guard_arg_dep),
                    args_tainted_cond = guard_arg_dep band args_tainted, 
                    sv_tainted_cond   =  guard_sv_dep band sv_tainted,
                    is_tainted = (args_tainted_cond band (bnot args_sndr)) bor sv_tainted_cond, // For conditionals, we examine taint coming only from non-sndr sources? 
                    (
                        (is_tainted != 0, state_end = 3, final_imp_blk = last_blk); // If yes, then next state is antiguarded (o/w the next state can only be accessed by priv'd user since it is guarded)
                        (is_tainted = 0, state_end = 2, final_imp_blk = "")
                    )
                )
            )
        ),
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 13.

// Case 3.1: antiguarded privilege
// This case happens if we are currently in the anti-guarded state and then encounter the end of the ctrl flow induced by the tainted if-condition.
// Since we are in the unprivileged state, we need to make sure there is no guard.

// As we are moving to a node of convergence (of all tainted if branches), the state will be normal again and the imp_taint vars will all be reset
// we get: final_imp_taint = 0, final_imp_blk = "", state_end = 2
program_run([executed_blks, to_blk], final_state, args_tainted, 2, -1, args_sndr, 0, "", hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 3, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        // If the next block is a convergence node (not leaf node, i.e. return or revert) for the tainted if condition, then we exit the tainted state
        // and we transfer the lightly tainted arguments over to the to_blk's  (not lightly) tainted arguments
        mustPassThru(imp_blk, to_blk), //!(return(_, to_blk); revert(_, to_blk)), 
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, _),
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = arg_taint_dep bor sv_taint_dep,
                sv_bv(bv, field), 
                (   
                    (is_sv_val_taint != 0, final_state = (bv bor sv_tainted) bor imp_taint); // if we are exiting the antiguard, we apply the implicit taint to the final state
                    (is_sv_val_taint = 0, final_state = (bnot bv) band (sv_tainted bor imp_taint)) // we give priority to cleaning for precision as it is done after the implicit taint
                )
            );
            (
                !doesModify(to_blk), final_state = sv_tainted bor imp_taint
            )
        ), 
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 13.

// Case 3.2: antiguarded privilege
// This case happens if we are currently in the anti-guarded state but do NOT encounter the end of the ctrl flow induced by the tainted if-condition 
program_run([executed_blks, to_blk], final_state, args_tainted, 3, -1, args_sndr, final_imp_taint, imp_blk, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 3, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        // If the next block is not a convergence node (and not leaf node, i.e. return or revert) for the tainted if condition, then we 
        // continue in the same state we were
        !mustPassThru(imp_blk, to_blk), 
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, _),
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = arg_taint_dep bor sv_taint_dep,
                sv_bv(bv, field), 
                (   
                    (is_sv_val_taint != 0, final_state = bv bor sv_tainted); // if we are exiting the antiguard, we apply the implicit taint to the final state
                    (is_sv_val_taint = 0, final_state = (bnot bv) band sv_tainted) // we give priority to cleaning for precision as it is done after the implicit taint
                ),
                // Since the to_blk happens to be in the tainted ctrl-flow we add the implicit taint on it
                final_imp_taint = imp_taint bor bv
            );
            (
                !doesModify(to_blk), final_state = sv_tainted, final_imp_taint = imp_taint
            )
        ), 
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 13.


//.output blockFollows
//  ******************* START: JUMP LOGIC  *******************
// Handle jump arguments and stack (ungarded). Amro: removed the stack from here since it was being done in the JMP CTRL transfer below
program_run(executed_blks, sv_tainted, final_arg_state, state, idx, final_args_sndr, imp_taint, imp_blk, hs, stack, prehist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist),
        executed_blks = [prev_exec, last_blk], jump(_, last_blk, to_blk, cont_blk), idx = last_arg + 1,
        (
            (arg_flow(arg, id_val, idx, last_blk, to_blk), !longBlock(to_blk));
            (arg_flow(arg, id_val, idx, last_blk, child), first_mini_blk(to_blk, child))
        ), 
        ssa_depens_complete(id_val, args_val, sv_val, sndr_val, cnt_val),
        // Implicitly taint everything stemming from a anti-guarded state
        
        sndr_dep_complete = sndr_val bor (args_val band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
        safe_sndr = -state/2, // wil be 0b1...1 if state > 1 i.e. privileged        
        sndr_val_comp = sndr_dep_complete band (bnot safe_sndr),

        arg_taint_dep = args_val band (args_tainted band (bnot args_sndr)),
        sv_taint_dep = sv_val band sv_tainted, 
        is_imp_tainted = -1*(state band 1),
        non_sndr_taint = arg_taint_dep bor sv_taint_dep bor is_imp_tainted, // since we remain here inside the context of the if statement, consts are still clean (see twelve)
        is_id_val_taint = non_sndr_taint bor sndr_val_comp, // sndr_val_comp is equiv. to sndr_dep_complete only if untrusted senter
        (
            (is_id_val_taint != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted);
            (is_id_val_taint = 0, arg_bv(bv, arg), final_arg_state = (bnot bv) band args_tainted)  // 24.sol sometimes an argument needs to be cleaned b/c same function is called again with clean variable
        ),
        (   // notice that unlike the is_id_val_taint here, sndr_dep_complete since we want to know if there is a dependency regardless whether msg sender is trusted or not
            (non_sndr_taint = 0, sndr_dep_complete != 0,  arg_bv(bv, arg), final_args_sndr = bv bor args_sndr); // if the only taint comes from the sndr, then include it in the bit vector
            ((non_sndr_taint != 0; sndr_dep_complete = 0),  arg_bv(bv, arg), final_args_sndr = (bnot bv) band args_sndr) // o/w remove it from args_sndr flag if there is non-sndr taint or no dependence on sndr
        ).


// Jump ctrl transfer (longBlock logic to be done later)
program_run([executed_blks, to_blk], final_state, args_tainted, state, -1, args_sndr, final_imp_taint, imp_blk, hs+1, new_stack, currhist) :-   
         program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _) // either the block we're flowing into does not take arguments or the block we're flowing out of does not provide arguments
        ),
         executed_blks = [prev_exec, last_blk], jump(_, last_blk, parent_blk, cont_blk), !arg_setup_blk(last_blk),
         new_stack = [stack, cont_blk],  ((!longBlock(parent_blk), to_blk = parent_blk);
         (longBlock(parent_blk), !not_first_store(to_blk, sid, parent_blk), store_block(to_blk, parent, sid))),
         (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),
                sndr_dep_complete = sndr_dep bor (arg_dep band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
                safe_sndr = -state/2, // wil be 0b1...1 if state > 1 i.e. privileged        
                sndr_val = sndr_dep_complete band (bnot safe_sndr),
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,
                (
                    (is_sv_val_taint != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                    (is_sv_val_taint = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                ),
                final_imp_taint = ((state band 1)*bv) bor imp_taint
            );
            // block does not modify sv 
            (
                !doesModify(to_blk), final_state = sv_tainted, final_imp_taint = imp_taint
            )
         ), currhist = cat(cat(prehist, "-J->"), to_blk),
         hs < 13.


// Return ctrl transfer 
// R1.1, for this case we assume we have arrived at a leaf node of a tainted ctrl-flow induced by a tainted if condition
program_run([executed_blks, to_blk], final_state, args_tainted, state, -1, args_sndr, 0, "", hs+1, new_stack, currhist) :-  // remove implicit flag by banding by -2
         program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], mustPassThru(imp_blk, last_blk), 
        return(_, last_blk), stack = [prev_stack, parent_blk], 
        new_stack = prev_stack,  ((!longBlock(parent_blk), to_blk = parent_blk);
        (longBlock(parent_blk), !not_first_store(to_blk, sid, parent_blk), store_block(to_blk, parent, sid))),
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),
                sndr_dep_complete = sndr_dep bor (arg_dep band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
                safe_sndr = -state/2, // wil be 0b1...1 if state > 1 i.e. privileged        
                sndr_val = sndr_dep_complete band (bnot safe_sndr),
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,
                (
                    (is_sv_val_taint != 0, sv_bv(bv, field), final_state = bv bor (sv_tainted bor imp_taint));
                    (is_sv_val_taint = 0, sv_bv(bv, field), final_state = (bnot bv) band (sv_tainted bor imp_taint))
                )
            );
            // block does not modify sv 
            (
                !doesModify(to_blk), final_state = sv_tainted bor imp_taint
            )
        ), currhist = cat(cat(prehist, "-R->"), to_blk),
        hs < 13.

// Return ctrl transfer 
// R1.2, for this case we assume are NOT at a leaf node of a tainted ctrl-flow induced by a tainted if condition
program_run([executed_blks, to_blk], final_state, args_tainted, state, -1, args_sndr, final_imp_taint, imp_blk, hs+1, new_stack, currhist) :-  // remove implicit flag by banding by -2
         program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], !mustPassThru(imp_blk, last_blk), 
        return(_, last_blk), stack = [prev_stack, parent_blk], 
        new_stack = prev_stack,  ((!longBlock(parent_blk), to_blk = parent_blk);
        (longBlock(parent_blk), !not_first_store(to_blk, sid, parent_blk), store_block(to_blk, parent, sid))),
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),
                sndr_dep_complete = sndr_dep bor (arg_dep band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
                safe_sndr = -state/2, // wil be 0b1...1 if state > 1 i.e. privileged        
                sndr_val = sndr_dep_complete band (bnot safe_sndr),
                arg_taint_dep = arg_dep band (args_tainted band (bnot args_sndr)), // For precision, I made sure to exclude args_sndr since it is taken into account (along with user privilege) in the lines before
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,
                (
                    (is_sv_val_taint != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                    (is_sv_val_taint = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                ),
                final_imp_taint = ((state band 1)*bv) bor imp_taint
            );
            // block does not modify sv 
            (
                !doesModify(to_blk), final_state = sv_tainted, final_imp_taint = imp_taint 
            )
        ), currhist = cat(cat(prehist, "-R->"), to_blk),
        hs < 13.

//.output mustPassThru
// Return argument transfer
program_run(executed_blks, sv_tainted, final_arg_state, state, idx, final_args_sndr, imp_taint, imp_blk, hs, stack, prehist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist),   // 00013   clean it --> 00001 but this DOES NOT MEAN 00013 is gone
        executed_blks = [prev_exec, last_blk], return(_, last_blk), stack = [prev_stack, possible_parent_blk], 
        ((longBlock(possible_parent_blk), first_mini_blk(possible_parent_blk, to_blk));(!longBlock(possible_parent_blk), to_blk = possible_parent_blk)),
        arg_flow(arg, id_val, idx, last_blk, to_blk),
        idx = last_arg+1 ,ssa_depens_complete(id_val, args_val, sv_val, sndr_val, cnt_val),
        // Fix for twenty.sol, it is possible that the new argument is tainted by msg.sendr via another argument which is itself (only) tainted by msg.sender
       
        sndr_dep_complete = sndr_val bor (args_val band args_sndr), // there could be a direct dependency on msg.sender or indirect via an argument
        safe_sndr = -state/2, // wil be 0b1...1 if state > 1 i.e. privileged        
        sndr_val_comp = sndr_dep_complete band (bnot safe_sndr),

        arg_taint_dep = args_val band (args_tainted band (bnot args_sndr)),
        sv_taint_dep = sv_val band sv_tainted, 
        is_imp_tainted = -1*(state band 1),
        non_sndr_taint = arg_taint_dep bor sv_taint_dep bor is_imp_tainted, // since we remain here inside the context of the if statement, consts are still clean (see twelve)
        is_id_val_taint = non_sndr_taint bor sndr_val_comp, // sndr_val_comp is equiv. to sndr_dep_complete only if untrusted senter
        (
            (is_id_val_taint != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted);
            (is_id_val_taint = 0, arg_bv(bv, arg), final_arg_state = (bnot bv) band args_tainted)  // 24.sol sometimes an argument needs to be cleaned b/c same function is called again with clean variable
        ),
        (   // notice that unlike the is_id_val_taint here, sndr_dep_complete since we want to know if there is a dependency regardless whether msg sender is trusted or not
            (non_sndr_taint = 0, sndr_dep_complete != 0,  arg_bv(bv, arg), final_args_sndr = bv bor args_sndr); // if the only taint comes from the sndr, then include it in the bit vector
            ((non_sndr_taint != 0; sndr_dep_complete = 0),  arg_bv(bv, arg), final_args_sndr = (bnot bv) band args_sndr) // o/w remove it from args_sndr flag if there is non-sndr taint or no dependence on sndr
        ).

//  ******************* END: JUMP LOGIC  *******************


// ******************* START: FUNCTION EXECUTION FINISHED *******************

.decl hasSelfDestruct(blk: Block)
hasSelfDestruct(blk) :- statement(stmt), blockStmt(blk, stmt), selfdestruct(stmt, _).


// return to argument setup block (from normal return). NB: the arguments are reset as untainted
program_run([executed_blks, to_blk], sv_tainted bor imp_taint, 0, 0, -1, 0, 0, "", hs+1, stack, currhist) :- 
    program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), 
    executed_blks = [prev_exec, last_blk], return(_, last_blk), stack = nil, arg_setup_blk(to_blk),
    (
        (state < 2); // only go the block which sets up user taint if we are not the admin user
        (
            (state > 1), !hasSelfDestruct(last_blk)
        )
    ), 
    sv_tainted != 0,
    currhist = cat(cat(prehist, "=>"), to_blk),
    hs < 13. 

// return to privileged user from unprivileged user return (privileged user does not introduce user input taint -> no need for arg_setup_blk)
program_run([executed_blks, to_blk], sv_tainted bor imp_taint, 0, 2, -1, 0, 0, "", hs+1, nil, currhist) :- 
    program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, args_sndr, imp_taint, imp_blk, hs, stack, prehist), 
    executed_blks = [prev_exec, last_blk], return(_, last_blk), stack = nil,
    function(parent_blk, x), x != "Constructor",  
    (
        (!longBlock(parent_blk), to_blk = parent_blk);
        (longBlock(parent_blk), !not_first_store(to_blk, _, parent_blk), store_block(to_blk, parent, _))
    ),
    currhist = cat(cat(prehist, "=>"), to_blk),
    state < 2,
    sv_tainted != 0,
    hs > 1, hs < 13. 

// setup arguments inside argument setup block
program_run(executed_blks, sv_tainted, args_tainted bor arg_taint, 0, idx, args_sndr, 0, "", hs, stack, prehist) :- 
    program_run(executed_blks, sv_tainted, args_tainted, 0, last_arg, args_sndr, _, _, hs, stack, prehist), 
    executed_blks = [prev_exec, last_blk], arg_setup_blk(last_blk),  // if you append new history here, this rule will run forever and program will crash
    argument(id, substr(last_blk, 3, strlen(last_blk)),idx), idx=last_arg+1, arg_bv(arg_taint, id),  // no need to worry about the case where there is no arguments 
    hs < 13. 

// ******************* END: FUNCTION EXECUTION FINISHED *******************


// ******************* START: SELFDESTRUCT LOGIC *******************
.decl debug_info(executed_blks: BlkList, sv_state: number, arg_state: number, guarded: number, la : number, argsndr: number, imp_taint: number, imp_blk: Block, hist_size: number, stack: BlkList, string_hist: symbol)
//debug_info(executed_blks, sv_tainted, args_tainted, state, hs,stack, hist) :- program_run(executed_blks, sv_tainted, args_tainted, state, hs,stack, hist), state = 2.


// TODO: check also for state 3 (privileged but antiguarded)
tainted_sinks("id"), debug_info(executed_blks, sv_tainted, args_tainted, state, la, args_sndr, imp_taint, imp_blk, hs,stack, hist) :-selfdestruct(id, addr), program_run(executed_blks, sv_tainted, args_tainted, state, la, args_sndr, imp_taint,imp_blk,  hs,stack, hist), blockStmt(last_blk, id),
                    executed_blks = [prev_blks, last_blk], ssa_depens_complete(addr, args_dep, sv_dep, sndr, cnt), 
                    has_tainted_arg = args_dep band args_tainted, has_tainted_sv = sv_dep band sv_tainted, 
                    (
                        (is_tainted = has_tainted_arg bor has_tainted_sv bor sndr,(state=0; state=1));
                        (is_tainted = has_tainted_arg bor has_tainted_sv, (state = 2; state = 3))
                    ),
                    is_tainted != 0.

//.output debug_info
.output program_run
.output tainted_sinks
//.output blockFollows
//.output arg_setup_blk
//.output num_args
//.output arg_flow
//.output conditioned_block
/*.output blockDominates
.output blockFollows
.output hasGuardSSA
.output unguardedTaintedSSA
.output guardSSA
.output taintedSSA
*/



/*

            // If there is a straight edge between last_blk and to_blk, then 
            (unconditioned_block(last_blk), state_end = 1);
            (   
                conditioned_block(last_blk, guard_sv_dep, guard_arg_dep, guard_sndr_dep),
                (
                    args_tainted_cond = guard_arg_dep band args_tainted, 
                    sv_tainted_cond   =  guard_sv_dep band sv_tainted,
                    is_tainted = (args_tainted_cond band (bnot args_sndr)) bor sv_tainted_cond, // For conditionals, we examine taint coming only from non-sndr sources? 
                    (
                        ( 
                            guard_sndr_dep = 1, is_tainted != 0, state_end = 1 // If yes, then next state is antiguarded (o/w the next state can only be accessed by priv'd user since it is guarded)
                        );
                        (
                            guard_sndr_dep = 0, // there is no EXPLICIT dependency, but could there be an implicit one?
                            depends_on_sndr = args_sndr band guard_arg_dep,   // depends_on_sndr is non zero if there are arguments which are tainted by sndr (only) and are referenced by the condition
                            (
                                (
                                    depends_on_sndr = 0,  // no dependency on arguments which are tainted by sndr only --> this cannot be a guard
                                    // Not a guard --> we remain in antiguarded unprivleged state
                                    state_end = 1
                                );
                                (
                                    depends_on_sndr != 0,  // There is a dependency on arguments which are tainted by sndr only --> this can possibly be a guard
                                    // Could there be a non-sndr taint in the condition?
                                    is_tainted != 0, state_end = 1 // If there is taint, then next state is antiguarded (o/w the next state can only be accessed by priv'd user since it is guarded)      
                                )
                            )
                        )
                    )
                )
            )
*/
