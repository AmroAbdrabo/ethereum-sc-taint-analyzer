#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA) 
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)
.decl return(id_transfer: Transfer, id_block_from: Block)
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

#ifdef ENABLE_INPUT_FROM_FILES
.input function
.input block
.input blockStmt
.input follows
.input argument
.input statement
.input assign
.input const
.input uop
.input bop
.input load
.input structLoad
.input store
.input structStore
.input goto
.input branch
.input return
.input jump
.input transferArgument
.input selfdestruct
.input revert
.input builtinVariable


// -- output relations --
.decl tainted_sinks(id: SSA)

// Useful (wallah)
.decl msgSender(id: SSA)
msgSender(id) :-  builtinVariable(id, "SENDER").
msgSender(id) :-  assign(id, orig), msgSender(orig).
msgSender(id) :-  uop(id, orig, _), msgSender(orig).

// Transitively close constants. TODO: include as const if it is a bop or uop on constants 
const(id, value) :- assign(id, orig), const(orig, value).
// Transitively close load
load(id, field) :-  assign(id, orig), load(orig, field).
load(id, field) :-  uop(id, orig, _), load(orig, field).

// Helpher function: check if something depends on an argument
.decl user_input(id: SSA, depends_on_arg: SSA)
user_input(id, id) :- argument(id,_,_).
user_input(id, arg) :- assign(id, orig), user_input(orig, arg).
user_input(id, arg) :- uop(id, orig, _), user_input(orig, arg).

// Given that arguments are used only once we can treat similarly to fields
.decl activate_arg_taint(state: number, id_arg: SSA)
activate_arg_taint(s, id) :- s = 2^k, k = to_number(substr(id, 1, strlen(id))), argument(id, _, _).

.decl arg_cnt(cnt:number)
arg_cnt(cnt) :- cnt = count:{activate_arg_taint(_,_)}.

// Check if something depends only on constants
.decl depon_const_info(id: SSA)
depon_const_info(id) :- const(id, _); (const(orig, _), assign(id, orig)).
depon_const_info(id) :- bop(id, id_lhs, id_rhs, _), (depon_const_info(id_lhs); depon_const_info(id_rhs)).
depon_const_info(id) :- uop(id, id_orig, _), depon_const_info(id_orig). 

.decl ssa_depens(stmt: SSA, args: number, sv: number, sndr: number, cnt: number) // the things an SSA depends on
// Base cases
ssa_depens(id, 0, 0, 0, 0) :- depon_const_info(id).
ssa_depens(id, s, 0, 0, 1) :- user_input(id, arg), activate_arg_taint(s, arg).
ssa_depens(id, 0, s, 0, 1) :- load(id, field), activate_taint(s, field).
ssa_depens(id, 0, 0, 1, 0) :- msgSender(id).

// Tree recursion
ssa_depens(id, args, sv, sndr, cnt)  :- (assign(id, orig); uop(id, orig, _)), ssa_depens(orig, args, sv, sndr, cnt).
ssa_depens(id, args_lhs bor args_rhs, sv_lhs bor sv_rhs, sndr_lhs bor sndr_rhs, cnt_lhs + cnt_rhs)  :- bop(id, id_lhs, id_rhs, _), 
                  ssa_depens(id_lhs, args_lhs, sv_lhs, sndr_lhs, cnt_lhs),  
                  ssa_depens(id_rhs, args_rhs, sv_rhs, sndr_rhs, cnt_rhs). 
                  // and operation is to ensure no var is taken into account more than once

// USE ONLY COMPLETE VERSION WITH MAX CNT
.decl ssa_dep_incomplete(stmt: SSA, args: number, sv: number, sndr: number, cnt: number)
ssa_dep_incomplete(id, args, sv, sndr, cnt) :- ssa_depens(id, args, sv, sndr, cnt), ssa_depens(id, args2, sv2, sndr2, cnt2), 
                                                tot_edges2 = args2 + sv2 + sndr2, tot_edges = args + sv + sndr, tot_edges2 > tot_edges.

.decl ssa_depens_complete(stmt: SSA, args: number, sv: number, sndr: number, cnt: number)
ssa_depens_complete(id, args, sv, sndr, cnt) :- ssa_depens(id, args, sv, sndr, cnt), !ssa_dep_incomplete(id, args, sv, sndr, cnt).


// Encode each state variable as a one-hot vector. (Assuming there are 3 state variables) 000 means all state variables are untainted, 001 means only first field, V00, is tainted
.decl activate_taint(state: number, field: Name)

// These inputs are generated/written by Python (found a way to do them in dl)
activate_taint(s, field) :- s = 2^k, k = to_number(substr(field, 1, strlen(field))), store(_, field, _). // one-hot encoding

.decl field_cnt(cnt:number)
field_cnt(cnt) :- cnt = count:{activate_taint(_,_)}.

.decl deactivate_taint(state: number, field: Name) 
// Unfortunately we only need 3 bits but datalog gives us 32 hence the need for 
// 0b111 mask (i.e. 7)
deactivate_taint(bnot tainted, field) :- activate_taint(tainted, field). 

.type BlkList = [next: BlkList, blk: Block]


// taints or cleans, depending on whether state_dependency and arg_dependency references tainted values
.decl block_taints_sv(blk: Block, sv: Name, state_dependency: number, arg_dependency: number, sndr: number)
block_taints_sv(blk, field, state_dep, arg_dep, sndr_dep) :- store(stmt, field, assigned),
  blockStmt(blk, stmt), ssa_depens_complete(assigned, arg_dep, state_dep, sndr_dep, _). 

// *********************** END BLOCK CLEANING STATE VARIABLES ****************************

// We consider a (later guard) condition to be safe if it does not depend on user provided arguments. However, we keep
// track of which state variables it depends on.
.decl safe_condition(stmt: SSA, state_dependency: number, arg_dependency: number)  
// (Potentially) safe condition with dependency on state variables
safe_condition(stmt, sv, arg) :- ssa_depens_complete(stmt, arg, sv, 1, _). 

// TODO: take into account argument transfers (see example 8)  
.decl safe_guarded_block(blk: Block, state_dependency: number, arg_dependency: number)
safe_guarded_block(blk, state_dependency, arg_dependency) :- safe_condition(stmt, state_dependency, arg_dependency), branch(_,_, blk,_,_, stmt).// blockStmt(blk,stmt). block with safe guard condition need not have the var_cond defined inside the block (example: T0:: A02)

.decl unguarded_block(blk: Block)
unguarded_block(blk) :- block(blk), !safe_guarded_block(blk, _). // NB: a block can also be "unguarded" if some of its dependencies become tainted

// ***************** information transfer *****************
.decl arg_flow(arg: SSA, id_val: SSA, idx: number, block_from: Block, block_to: Block)
arg_flow(arg, id_val, idx, block_from, block_to) :- transferArgument(transfer, id_val, idx), 
                                                    (
                                                      goto(transfer, block_from, block_to);
                                                      jump(transfer, block_from, block_to, _);
                                                      (jump(transfer_orig, _, block_from, block_to), return(transfer, block_from)) // when the called function is done
                                                      // does not seem to be case that a branch transfers any arguments (tho I might be wrong)
                                                    ), argument(arg, block_to, idx).


// ***************** end: information transfer *****************
.decl longBlock(longblk: Block)
longBlock(blk) :- store(id1, _, _), blockStmt(blk, id1), store(id2, _, _), blockStmt(blk, id2), id1 != id2, !function(blk,"Constructor"). 


.decl store_block_follows(from_stmt: number, to_stmt: number, parent: Block)
store_block_follows(from, to, parent) :- store_block(_, parent, from), store_block(_, parent, to), from < to.

.decl not_follows_immediately(from: number, to: number, parent: Block)
not_follows_immediately(from, to, parent) :- not_follows_immediately(from, mid, parent), 
  not_follows_immediately(mid, to, parent), mid < to, mid > from.

// connect all the individual store blocks together
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, parent, sid_from),
  store_block(id_block_to, parent, sid_to), !not_follows_immediately(sid_from, sid_to, parent).

.decl not_first_store(sblk: Block, sid: number, parent: Block)
not_first_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(sblk2, parent, sid2), sid2 < sid.

.decl not_last_store(sblk: Block, sid: number, parent: Block)
not_last_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(sblk2, parent, sid2), sid2 > sid.


.decl store_block(store_block: Block, parent_block: Block, stmt_order: number)
block(sblk), blockStmt(sblk, stmt), store_block(sblk, parent, order) :- 
  store(stmt, _, _), blockStmt(parent, stmt), sblk = cat(parent, stmt), 
  order = to_number(substr(stmt, 1, strlen(stmt))), longBlock(parent).   


// Now make sure every other function block (apart from constructor) follows from constructor
.decl blockFollows(id_block_from: Block, id_block_to: Block)

// from the last store of a parent block to the parent block itself (which we segmented into multiple stores)
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, id_block_to, _), 
  											!not_last_store(id_block_from, _, id_block_to).
  											
// There is a follows relation b/w blocks in case of 1: goto 2: branch 3: jump 
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, id_block_to), !longBlock(id_block_to).

// If it is a multistore block, go to the first store block instead
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, parent), longBlock(parent), 
  											!not_first_store(id_block_to, _, parent), store_block(id_block_to, _, _).
// Branch without multistore blocks
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, id_block_to, _, _); 
                                             branch(_, _, id_block_from, _, id_block_to, _)), !longBlock(id_block_to).

// Branch with multistore blocks (same as before: go to the first store block)
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, parent, _, _); 
                                             branch(_, _, id_block_from, _, parent, _)), 
  											longBlock(parent), !not_first_store(id_block_to, _, parent), 
                                              store_block(id_block_to, _, _).


// From the constructor, every start of a function follows
// Before the execution of the user-called function there is a helper block which helps sets up the taint for the input supplied by the user
.decl arg_setup_blk(blk: Block)
arg_setup_blk(blk), block(blk) :- blk = cat(con_blk, f_blk), function(con_blk, "Constructor"), function(f_blk, fname), fname != "Constructor".
blockFollows(conblk, setup_blk), blockFollows(setup_blk, fblk) :-  arg_setup_blk(setup_blk), fblk = substr(setup_blk, 3, strlen(setup_blk)), function(conblk, "Constructor").
.output blockFollows

.decl terminating_ret(blk: Block)
terminating_ret(blk) :- (return(_, blk); revert(_,blk)), !jump(_, _, blk, _).
blockFollows(termblk, fctblk) :- terminating_ret(termblk), function(fctblk, fctname), fctname!="Constructor".

.decl program_run(executed_blks: BlkList, sv_state: number, arg_state: number, guarded: number, hist_size: number, stack: BlkList, string_hist: symbol) // final state after executing blklist
// base case
program_run([nil, constructor_block], 0, 0, 0, 1, nil, constructor_block) :- function(constructor_block, "Constructor").

// TODO: Come up with a way to avoid subsetting a string with substring length of 3
// from the constructor to an intermediary block which setsup the taint on the user-defined arguments
program_run([executed_blks, toblk], 0, arg_taint, 0, 2, nil, currhist) :-  program_run(executed_blks, 0, 0, 0, 1, nil, conblk),
                                                                              function(conblk, "Constructor"), blockFollows(conblk, toblk), 
                                                                              argument(id, substr(toblk, 3, strlen(toblk)), _), activate_arg_taint(arg_taint, id),
                                                                              executed_blks = [nil, conblk], currhist = cat(con_blk, toblk). 

// If we are currently at the argument setup block (for user defined input) 
program_run([executed_blks, toblk], sv_taint, args_tainted bor arg_taint, 0, hs+1, stack, currhist) :-  program_run(executed_blks, sv_taint, args_tainted, 0, hs, stack, prehist),
                                                                              blockFollows(last_exec_blk, toblk), arg_setup_blk(toblk),
                                                                              argument(id, substr(toblk, 3, strlen(toblk)), _), activate_arg_taint(arg_taint, id),
                                                                              executed_blks = [ancient_list, last_exec_blk], currhist = cat(prehist, toblk). 
// If we are currently at a store block then setup a taint (or untaint)
program_run([executed_blks, toblk], sv_taint, args_tainted bor arg_taint, 0, hs+1, stack, currhist) :-  program_run(executed_blks, sv_taint, args_tainted, 0, hs, stack, prehist),
                                                                              blockFollows(last_exec_blk, toblk),  executed_blks = [ancient_list, last_exec_blk],
                                                                              argument(id, substr(toblk, 3, strlen(toblk)), _), activate_arg_taint(arg_taint, id),
                                                                               currhist = cat(prehist, currhist). 



// If the flow so far is unguarded and the next (current) block is unguarded or has a guard which
// depends on tainted state variables then the next state is unguarded. If the current block taints 
// some state variables then we maintain these taints in the next state. Otherwise, we leave the taints as they are.

// TODO declare a has jump condition in order to be able to push off the stack

program_run([executed_blks, current_blk], tainted_fields bor curr_tainted, tainted_args, 0, hs+1, currhist)  :- 
  program_run(executed_blks, tainted_fields, tainted_args, 0, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk],
  			(
  				(!block_taints_complete(current_blk, _, _), curr_tainted = 0);
  				block_taints_complete(current_blk, curr_tainted, _)
			  )
			,(
              	unguarded_block(current_blk);
               (safe_guarded_block(blk, sv), sv band (tainted_fields bor curr_tainted) != 0)
        ).

// If a program cleans a state variable
program_run([executed_blks, current_blk], tainted_fields band curr_cleaned, tainted_arg, 0, hs+1, currhist)  :- 
  program_run(executed_blks, tainted_fields,tainted_arg, 0, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk],
  			(
  				(!block_removes_taint_complete(current_blk, _, _), curr_cleaned = 0);
  				block_removes_taint_complete(current_blk, curr_cleaned, _)
			  )
			,(
              	unguarded_block(current_blk);
               (safe_guarded_block(blk, sv), sv band (tainted_fields band curr_cleaned) != 0)
        ).

// Guarded flow remains guarded until it terminates
program_run([executed_blks, current_blk], tainted_fields, tainted_arg, 1, hs+1, currhist) :- 
  program_run(executed_blks, tainted_fields, tainted_arg, 1, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], !terminating_ret(current_blk).
 
// Here, the guarded flow terminates
program_run([executed_blks, current_blk], tainted_fields,tainted_arg, 2, hs+1, currhist) :- 
  program_run(executed_blks, tainted_fields, tainted_arg, 1, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], terminating_ret(current_blk).
  			
// Guarded flow from an unguarded flow if there is a guard
program_run([executed_blks, current_blk], tainted_fields, tainted_arg, 1, hs+1, currhist) :- 
  program_run(executed_blks, tainted_fields, tainted_arg, 0, hs, hist), currhist = cat(hist, current_blk), hs < 9, block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], 
  			(
  				(!block_taints_complete(current_blk, _, _), curr_tainted = 0);
  				block_taints_complete(current_blk, curr_tainted, _)
			  ), safe_guarded_block(blk, sv), sv band (tainted_fields bor curr_tainted) = 0.

.decl debugInfo(executed_blks: BlkList, tfields: number, currhist: symbol)

tainted_sinks(stmt), debugInfo(executed_blks, tainted_fields, currhist):-
  			selfdestruct(stmt, addr), blockStmt(current_blk, stmt),
  			program_run(executed_blks, tainted_fields, tainted_arg, 0, _, currhist), block(prev_blk), blockFollows(prev_blk, current_blk), 
  			executed_blks = [finished_blks, prev_blk], 
  			(
  				(!block_taints_complete(current_blk, _, _), curr_tainted = 0);
  				block_taints_complete(current_blk, curr_tainted, _)
			  )
		    ,(msgSender(addr); // addr of self destruct is msgsender, a tainted field, or is a bop which depends on user input (e.g. A01)
            	(
              		activate_taint(s, field), load(addr, field), s band (curr_tainted bor tainted_fields) != 0
				      );          
                (bop(stmt, _, _, _), !safe_condition(addr, _))
         ).

//tainted_sinks(id) :- selfdestruct(id, _).

.output program_run
.output deactivate_taint
.output tainted_sinks
.output debugInfo
/*.output blockDominates
.output blockFollows
.output blockFollowsTransitive
.output notDominates
.output hasGuardSSA
.output unguardedTaintedSSA
.output guardSSA
.output taintedSSA
.output taintedStorage
.output context
.output fields
*/