#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA) 
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)
.decl return(id_transfer: Transfer, id_block_from: Block)
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

#ifdef ENABLE_INPUT_FROM_FILES
.input function
.input block
.input blockStmt
.input follows
.input argument
.input statement
.input assign
.input const
.input uop
.input bop
.input load
.input structLoad
.input store
.input structStore
.input goto
.input branch
.input return
.input jump
.input transferArgument
.input selfdestruct
.input revert
.input builtinVariable


// -- output relations --
.decl tainted_sinks(id: SSA)


// Useful (wallah)
.decl msgSender(id: SSA)
msgSender(id) :-  builtinVariable(id, "SENDER").
msgSender(id) :-  assign(id, orig), msgSender(orig).
msgSender(id) :-  uop(id, orig, _), msgSender(orig).

// Transitively close constants. TODO: include as const if it is a bop or uop on constants 
const(id, value) :- assign(id, orig), const(orig, value).
const(id, value) :- uop(id, orig, _), const(orig, value).

// Transitively close load
load(id, field) :-  assign(id, orig), load(orig, field).
load(id, field) :-  uop(id, orig, _), load(orig, field).

// Helper function: check if something depends on an argument
.decl user_input(id: SSA, depends_on_arg: SSA)
user_input(id, id) :- argument(id,_,_).
user_input(id, arg) :- assign(id, orig), user_input(orig, arg).
user_input(id, arg) :- uop(id, orig, _), user_input(orig, arg).

// Given that arguments are used only once we can treat similarly to fields. A01 -> 0010, A00 -> 0001, A02 
.decl arg_bv(state: number, id_arg: SSA)
arg_bv(s, id) :- s = 2^k, k = to_number(substr(id, 1, strlen(id))), argument(id, _, _).

.decl arg_cnt(cnt:number)
arg_cnt(cnt) :- cnt = count:{arg_bv(_,_)}.

// Check if something depends only on constants
.decl depon_const_info(id: SSA)
depon_const_info(id) :- const(id, _); (assign(id, orig), depon_const_info(orig)).
depon_const_info(id) :- bop(id, id_lhs, id_rhs, _), depon_const_info(id_lhs), depon_const_info(id_rhs).
depon_const_info(id) :- uop(id, id_orig, _), depon_const_info(id_orig).  

.decl ssa_depens_complete(stmt: SSA, args: number, sv: number, sndr: number, cnt: number) // the things an SSA depends on
// Base cases
ssa_depens_complete(id, 0, 0, 0, 0) :- depon_const_info(id).
ssa_depens_complete(id, s, 0, 0, 1) :- user_input(id, arg), arg_bv(s, arg). // (id, s, 0 , 0, 1)  id_var = id 
ssa_depens_complete(id, 0, s, 0, 1) :- load(id, field), sv_bv(s, field).
ssa_depens_complete(id, 0, 0, 1, 0) :- msgSender(id).

//.output ssa_depens_complete

// Tree recursion
ssa_depens_complete(id, args, sv, sndr, cnt)  :- (assign(id, orig); uop(id, orig, _)), ssa_depens_complete(orig, args, sv, sndr, cnt).
ssa_depens_complete(id, args_lhs bor args_rhs, sv_lhs bor sv_rhs, sndr_lhs bor sndr_rhs, cnt_lhs + cnt_rhs)  :- bop(id, id_lhs, id_rhs, _), 
                  ssa_depens_complete(id_lhs, args_lhs, sv_lhs, sndr_lhs, cnt_lhs),  
                  ssa_depens_complete(id_rhs, args_rhs, sv_rhs, sndr_rhs, cnt_rhs). 
                  // and operation is to ensure no var is taken into account more than once

/// ********************* Start: Store context in block *********************
.decl sv_bv(state: number, field: Name)

// For state variable taint activation
sv_bv(s, field) :- s = 2^k, k = to_number(substr(field, 1, strlen(field))), store(_, field, _). // one-hot encoding

.type BlkList = [next: BlkList, blk: Block]

// Context of store in a block // B00, S02, 010, 010, 1
.decl block_modifies_sv(blk: Block, sv: Name, state_dependency: number, arg_dependency: number, sndr: number)
block_modifies_sv(blk, field, state_dep, arg_dep, sndr_dep) :- store(stmt, field, assigned), !longBlock(blk),
  blockStmt(blk, stmt), ssa_depens_complete(assigned, arg_dep, state_dep, sndr_dep, _). 

/// ********************* END: Store context in block *********************

// We consider a (later guard) condition to be safe if it does not depend on user provided arguments. However, we keep
// track of which state variables and which arguments it depends on.
.decl safe_condition(stmt: SSA, state_dependency: number, arg_dependency: number)  
// (Potentially) safe condition with dependency on state variables
safe_condition(stmt, sv, arg) :- ssa_depens_complete(stmt, arg, sv, 1, _). 

// TODO: take into account argument transfers (see example 14)  
.decl safe_guarded_block(blk: Block, state_dependency: number, arg_dependency: number)
safe_guarded_block(blk, state_dependency, arg_dependency) :- safe_condition(stmt, state_dependency, arg_dependency), branch(_,_, blk,_,_, stmt).// blockStmt(blk,stmt). block with safe guard condition need not have the var_cond defined inside the block (example: T0:: A02)

.decl unconditioned_block(blk: Block)
// Captures blocks which are not guarded (as in those that do have a condition that does NOT depend on msg.sender, and also those that do not have a condition alas)
unconditioned_block(blk) :- block(blk), !branch(_, _, blk, _, _, _). // !safe_guarded_block(blk, _, _). // NB: a block can also be "unguarded" if some of its dependencies become tainted

// Conditioned but not guarded (i.e. has branch which has no dependence on msg.sender)
.decl unguarded_block(blk: Block, args: number, sv: number)
unguarded_block(blk, args, sv) :- branch(_, _, blk, _, _, stmt), ssa_depens_complete(stmt, args, sv, 0, _).

// ***************** argument transfer *****************
.decl blockFollowsClosed(start: Block, fin: Block)
blockFollowsClosed(start, fin) :- blockFollows(start, fin).
blockFollowsClosed(start, fin) :- blockFollows(start, mid), blockFollowsClosed(mid, fin).


.decl returnFromBlock(srcblk: Block, sinkblk: Block)
returnFromBlock(start, fin) :- blockFollowsClosed(start, fin), return(_, fin).
//.output returnFromBlock

.decl arg_flow(arg: SSA, id_val: SSA, idx: number, block_from: Block, block_to: Block)
arg_flow(arg, id_val, idx, block_from, block_to) :- transferArgument(transfer, id_val, idx), 
                                                    (
                                                      goto(transfer, block_from, block_to);
                                                      jump(transfer, block_from, block_to, _);
                                                      (jump(transfer_orig, _, block_from, block_to), return(transfer, block_from)); // when the called function is done
                                                      (jump(transfer_orig, _, block_from_upstream, block_to), returnFromBlock(block_from_upstream,  block_from), return(transfer, block_from))
                                                      // does not seem to be case that a branch transfers any arguments (tho I might be wrong)
                                                    ), argument(arg, block_to, idx), !longBlock(block_to).

arg_flow(arg, id_val, idx, block_from, block_to) :- transferArgument(transfer, id_val, idx), 
                                                    (
                                                      goto(transfer, block_from, parent);
                                                      jump(transfer, block_from, parent, _);
                                                      (jump(transfer_orig, _, block_from, parent), return(transfer, block_from)); // when the called function is done
                                                      (jump(transfer_orig, _, block_from, parent), returnFromBlock(block_from, retblk), return(transfer, retblk))
                                                      // does not seem to be case that a branch transfers any arguments (tho I might be wrong)
                                                    ), argument(arg, parent, idx), first_mini_blk(parent, block_to), longBlock(parent).

.decl num_args_interim(block_from: Block, block_to: Block, order: number, cnt: number)
num_args_interim(block_from, block_to, idx, 1) :- arg_flow(_, _, idx, block_from, block_to). // Souffle's cancerous witness problem prevents using a simple count functor

// unique way to construct num_args, namely by adding new arguments only in immediately consecutive order
num_args_interim(block_from, block_to, next_idx, cnt+1) :- num_args_interim(block_from, block_to, idx, cnt), arg_flow(_, _, next_idx, block_from, block_to), next_idx = idx+1.

.decl num_args_non_final(block_from: Block, block_to: Block, order: number, cnt: number)
num_args_non_final(block_from, block_to, order, cnt) :- num_args_interim(block_from, block_to, order, cnt), num_args_interim(block_from, block_to, order2, cnt2), cnt < cnt2.  

.decl num_args(block_from: Block, block_to: Block, cnt: number)
num_args(block_from, block_to, cnt) :- num_args_interim(block_from, block_to, idx, cnt), !num_args_non_final(block_from, block_to, idx, cnt).
num_args(block_from, block_to, 0) :- blockFollows(block_from, block_to), !hasArg(block_to).
num_args(block_from, block_to, 0) :- blockFollows(block_from, block_to), longBlock(block_to).

// argument setupblock 
num_args_interim(block_from, block_to, idx, 1) :- arg_setup_blk(block_from), 
            ((!longBlock(possible_parent), block_to = possible_parent);(first_mini_blk(possible_parent, block_to))), 
            possible_parent = substr(block_from, 3, strlen(block_from)), 
            argument(arg, possible_parent, idx).

num_args_interim(block_from, block_to, idx, cnt+1) :- num_args_interim(block_from, block_to, last, cnt), idx =last+1, arg_setup_blk(block_from),
    ((!longBlock(possible_parent), block_to = possible_parent);(first_mini_blk(possible_parent, block_to))), 
            possible_parent = substr(block_from, 3, strlen(block_from)), 
            argument(arg, possible_parent, idx).

// ***************** end: argument transfer *****************
.decl longBlock(longblk: Block)
longBlock(blk) :- store(id1, _, _), blockStmt(blk, id1), store(id2, _, _), blockStmt(blk, id2), id1 != id2, !function(blk,"Constructor"). 

.decl first_mini_blk(longblk: Block, entrypoint: Block)
first_mini_blk(longblk, entrypoint) :- longBlock(longblk), !not_first_store(entrypoint, _, longblk), store_block(entrypoint, longblk, _). 


.decl store_block_follows(from_stmt: number, to_stmt: number, parent: Block)
store_block_follows(from, to, parent) :- store_block(_, parent, from), store_block(_, parent, to), from < to.

.decl not_follows_immediately(from: number, to: number, parent: Block)
not_follows_immediately(from, to, parent) :- not_follows_immediately(from, mid, parent), 
  not_follows_immediately(mid, to, parent), mid < to, mid > from.

// connect all the individual store blocks together
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, parent, sid_from),
  store_block(id_block_to, parent, sid_to), sid_from < sid_to, !not_follows_immediately(sid_from, sid_to, parent).

.decl not_first_store(sblk: Block, sid: number, parent: Block)
not_first_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(_, parent, sid2), sid2 < sid.

.decl not_last_store(sblk: Block, sid: number, parent: Block)
not_last_store(sblk, sid, parent) :- store_block(sblk, parent, sid), store_block(_, parent, sid2), sid2 > sid.


.decl store_block(store_block: Block, parent_block: Block, stmt_order: number)
block(sblk), blockStmt(sblk, stmt), store_block(sblk, parent, order) :- 
  store(stmt, _, _), blockStmt(parent, stmt), sblk = cat(parent, stmt),
  order = to_number(substr(stmt, 1, strlen(stmt))), longBlock(parent).   


// Now make sure every other function block (apart from constructor) follows from constructor
.decl blockFollows(id_block_from: Block, id_block_to: Block)

// from the last store of a parent block to the parent block itself (which we segmented into multiple stores)
blockFollows(id_block_from, id_block_to) :- store_block(id_block_from, id_block_to, _), 
  											!not_last_store(id_block_from, _, id_block_to).
  											
// There is a follows relation b/w blocks in case of 1: goto 2: branch 3: jump 
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, id_block_to), !longBlock(id_block_to).

// If it is a multistore block, go to the first store block instead
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, parent), longBlock(parent), 
  											!not_first_store(id_block_to, _, parent), store_block(id_block_to, _, _).
// Branch without multistore blocks
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, id_block_to, _, _); 
                                             branch(_, _, id_block_from, _, id_block_to, _)), !longBlock(id_block_to).

// Branch with multistore blocks (same as before: go to the first store block)
blockFollows(id_block_from, id_block_to) :-  (branch(_, _, id_block_from, parent, _, _); 
                                             branch(_, _, id_block_from, _, parent, _)), 
  											longBlock(parent), !not_first_store(id_block_to, _, parent), 
                                              store_block(id_block_to, _, _).


// From the constructor, every start of a function follows
// Before the execution of the user-called function there is a helper block which helps sets up the taint for the input supplied by the user
.decl arg_setup_blk(blk: Block)
arg_setup_blk(blk), block(blk) :- blk = cat(con_blk, f_blk), function(con_blk, "Constructor"), function(f_blk, fname), fname != "Constructor".
blockFollows(conblk, setup_blk) :- arg_setup_blk(setup_blk), fblk = substr(setup_blk, 3, strlen(setup_blk)), function(conblk, "Constructor").
blockFollows(setup_blk, fblk) :-  arg_setup_blk(setup_blk), !longBlock(fblk), fblk = substr(setup_blk, 3, strlen(setup_blk)).
blockFollows(setup_blk, sblk) :-  arg_setup_blk(setup_blk), longBlock(fblk), fblk = substr(setup_blk, 3, strlen(setup_blk)), store_block(sblk, fblk, _), !not_first_store(sblk, _, fblk).
//.output blockFollows


// At the end of execution of executed_blks, sv_state determines the state variables which are tainted (have bit set to one),
// arg_state determines the arguments which are tainted (have bit set to one), guarded determines whether it is guarded (by the end of execution of executed_blks)
// string hist is B00B01
.decl program_run(executed_blks: BlkList, sv_state: number, arg_state: number, guarded: number, arg_stack: number, hist_size: number, stack: BlkList, string_hist: symbol) // final state after executing blklist
// base case
program_run([nil, constructor_block], 0, 0, 0, -1, 1, nil, "C") :- function(constructor_block, "Constructor").

//.output arg_flow
.decl hasArg(blk: Block)
hasArg(blk) :- argument(_, blk, _).

.decl doesModify(blk: Block)
doesModify(blk) :- block_modifies_sv(blk, _, _, _, _). 
// State 0: unguarded -  00
// State 1: antiguarded - 01
// State 2: privileged user (has untainted user input, but can act as a confused deputy-- see 14.sol) - 14
// State 3: privileged user running in antiguarded state (i.e. first bit determines whether we are in anti-guarded state or not. - 14
// Make sure to remove anti-guarded state on return (i.e. branch dependency finishes) 

// *********************** START: Normal ctrl flow (i.e. any ctrl flow other than JMP) *************************

// If we are currently at the argument setup block (for user defined input)  -- removed tainting new record's arguments, see the bottom-most rule
program_run([executed_blks, to_blk], sv_taint, args_tainted, 0, -1, hs+1, stack, currhist) :-  
        program_run(executed_blks, sv_taint, args_tainted, 0, -1, hs, stack, prehist),
        blockFollows(last_exec_blk, to_blk), arg_setup_blk(to_blk), // guaranteed to be following from constructor (only where we can reach arg_setup_blk is via constructor) 
        executed_blks = [ancient_list, last_exec_blk],
        //currhist = cat(prehist, cat("->",substr(to_blk, 3, strlen(to_blk)))).
        currhist = cat(cat(prehist, ","), to_blk).

// Handle argument taint transfer (ungarded)
program_run(executed_blks, sv_tainted, final_arg_state, state, idx, hs, stack, prehist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk),
        arg_flow(arg, id_val, idx, last_blk, to_blk), idx = last_arg+1, // push arguments in increasing order
        ssa_depens_complete(id_val, args_val, sv_val, sndr_val, cnt_val), 
        // NEW: if you look at the graph of twelve-one.sol A01 is tainted b/c depended impl. on tainted value
        // The reason twelve-one.sol was passing thus far, was b/c our state machine treated the argument A01 as tainted for a reason I still need to figure out
        arg_taint_dep = args_val band args_tainted,
        sv_taint_dep = sv_val band sv_tainted,
        is_id_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,
        (
            (is_id_val_taint != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted);
            (is_id_val_taint = 0, arg_bv(bv, arg), final_arg_state = args_tainted)  // 24.sol sometimes an argument needs to be cleaned b/c same function is called again with clean variable
        ),
        
        hs < 14.
//.output arg_flow
//.output num_args

// Handle state variable taint transfer (ungarded). New: checks first there is NO guard inside last_blk to know if we can still remain in unguarded state 

// Case 0: unguarded non-privileged user
program_run([executed_blks, to_blk], final_state, args_tainted, state_end, -1, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 0, last_arg, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),        
                    arg_taint_dep = arg_dep band args_tainted,
                    sv_taint_dep = state_dep band sv_tainted,
                    is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_dep,
                    (
                        (is_sv_val_taint != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                        (is_sv_val_taint = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                    )
            );
            (
                !doesModify(to_blk), final_state = sv_tainted
            )
        ), 
        (
            (unconditioned_block(last_blk), state_end = 0);
            (   
                safe_guarded_block(last_blk, guard_sv_dep, guard_arg_dep), 
                has_arg_dep = guard_arg_dep band args_tainted, 
                has_sv_dep =  guard_sv_dep band sv_tainted,
                is_tainted = has_arg_dep bor has_sv_dep,
                is_tainted != 0, state_end = 1
            );
            (
                unguarded_block(last_blk, args_dep, sv_dep),
                has_arg_dep = args_dep band args_tainted, 
                has_sv_dep =  sv_dep band sv_tainted,
                is_tainted = has_arg_dep bor has_sv_dep,
                ((is_tainted = 0, state_end = 0);(is_tainted != 0, state_end = 1))
            )
        ),
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 14.

// Case 1: antiguarded unprivileged state
program_run([executed_blks, to_blk], final_state, args_tainted, state_end, -1, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 1, last_arg, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),        
                    is_non_const_sv = arg_dep bor sndr_dep bor state_dep, // only tainted if non-constant
                    (
                        (is_non_const_sv != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                        (is_non_const_sv = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                    )
            );
            (
                !doesModify(to_blk), final_state = sv_tainted
            )
        ), 
        (
            (unconditioned_block(last_blk), state_end = 1);
            (
                // According to thirty-five.sol this is not correct, ctrl flow passes thru a guard (from twelve.sol and twevel-1.sol we see that inside the tainted if statement clean values remain clean until they get transferred out of the if statement)
                safe_guarded_block(last_blk, guard_sv_dep, guard_arg_dep), 
                has_arg_dep = guard_arg_dep band args_tainted, 
                has_sv_dep =  guard_sv_dep band sv_tainted,
                is_tainted = has_arg_dep bor has_sv_dep,
                is_tainted != 0, state_end = 1
            );
            (
                unguarded_block(last_blk, args_dep, sv_dep),
                state_end = 1
            )
        ),
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 14.

// Case 2: privileged user (no antiguard)
program_run([executed_blks, to_blk], final_state, args_tainted, state_end, -1, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 2, last_arg, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),        
                    arg_taint_dep = arg_dep band args_tainted,
                    sv_taint_dep = state_dep band sv_tainted,
                    is_sv_val_taint = arg_taint_dep bor sv_taint_dep,
                    (
                        (is_sv_val_taint != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                        (is_sv_val_taint = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                    )
            );
            (
                !doesModify(to_blk), final_state = sv_tainted
            )
        ), 
        (

            (unconditioned_block(last_blk), state_end = 2);
            (
                safe_guarded_block(last_blk, guard_sv_dep, guard_arg_dep), 
                has_arg_dep = guard_arg_dep band args_tainted, 
                has_sv_dep =  guard_sv_dep band sv_tainted,
                is_tainted = has_arg_dep bor has_sv_dep,
                ((is_tainted != 0, state_end = 3);(is_tainted = 0, state_end = 2)) // if the guard is tainted we go to anitguarded privilege state, o/w we remain in priv'd state
            );
            (
                unguarded_block(last_blk, args_dep, sv_dep),
                has_arg_dep = args_dep band args_tainted, 
                has_sv_dep =  sv_dep band sv_tainted,
                is_tainted = has_arg_dep bor has_sv_dep,
                ((is_tainted = 0, state_end = 2);(is_tainted != 0, state_end = 3))
            )
        ),
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 14.

//.output block_modifies_sv
//.output safe_guarded_block
// Case 3: antiguarded privilege
program_run([executed_blks, to_blk], final_state, args_tainted, state_end, -1, hs+1, stack, currhist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, 3, last_arg, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
        executed_blks = [prev_exec, last_blk], blockFollows(last_blk, to_blk), !arg_setup_blk(to_blk), // NOT SURE if !arg_setup_blk() is really needed
        (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),  
                is_non_const = arg_dep bor sndr_dep bor state_dep, // only tainted if non-constant
                (
                    (is_non_const != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                    (is_non_const = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                )      
            );
            (
                !doesModify(to_blk), final_state = sv_tainted
            )
        ), 
        state_end = 3,
        currhist = cat(cat(prehist, ","), to_blk),
        hs < 14.

//.output blockFollows
//  ******************* START: JUMP LOGIC  *******************
// Handle jump arguments and stack (ungarded). Amro: removed the stack from here since it was being done in the JMP CTRL transfer below
program_run(executed_blks, sv_tainted, final_arg_state, state, idx, hs, stack, prehist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist),
        executed_blks = [prev_exec, last_blk], jump(_, last_blk, to_blk, cont_blk), idx = last_arg + 1,
        (
            (arg_flow(arg, id_val, idx, last_blk, to_blk), !longBlock(to_blk));
            (arg_flow(arg, id_val, idx, last_blk, child), first_mini_blk(to_blk, child))
        ), 
        ssa_depens_complete(id_val, args_val, sv_val, sndr_val, cnt_val),
        arg_taint_dep = args_val band args_tainted,
        sv_taint_dep = sv_val band sv_tainted,
        is_id_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val, // ARE WE PRIV'D USER: IF YES, THEN FOR PRECISION REMOVE SNDR_VAL
        
        is_non_const = args_val bor sv_val bor sndr_val,
        is_imp_tainted = state band 1,
        should_be_imp_tainted = is_imp_tainted band is_non_const,
        (
            (
                should_be_imp_tainted != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted
            );
            (
                should_be_imp_tainted = 0,
                ((is_id_val_taint != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted);
                (is_id_val_taint = 0, arg_bv(bv, arg), final_arg_state = ((bnot bv) band args_tainted)))  // 24.sol sometimes an argument needs to be cleaned b/c same function is called again with clean variable
            )
        ).


// Jump ctrl transfer (longBlock logic to be done later)
program_run([executed_blks, to_blk], final_state, args_tainted, state, -1, hs, new_stack, currhist) :-   
         program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _) // either the block we're flowing into does not take arguments or the block we're flowing out of does not provide arguments
        ),
         executed_blks = [prev_exec, last_blk], jump(_, last_blk, parent_blk, cont_blk), !arg_setup_blk(last_blk),
         new_stack = [stack, cont_blk],  ((!longBlock(parent_blk), to_blk = parent_blk);
         (longBlock(parent_blk), !not_first_store(to_blk, sid, parent_blk), store_block(to_blk, parent, sid))),
         (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),        
                arg_taint_dep = arg_dep band args_tainted,
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_dep,
                (
                    (is_sv_val_taint != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                    (is_sv_val_taint = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                )
            );
            // block does not modify sv 
            (
                !doesModify(to_blk), final_state = sv_tainted
            )
         ), currhist = cat(cat(prehist, "-J->"), to_blk),
         hs < 14.


// Return ctrl transfer
program_run([executed_blks, to_blk], final_state, args_tainted, state band -2, -1, hs+1, new_stack, currhist) :-  // remove implicit flag by banding by -2
         program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist), (
            num_args(last_blk, to_blk, last_arg+1);
            !num_args(last_blk, to_blk, _)
        ),
         executed_blks = [prev_exec, last_blk], return(_, last_blk), stack = [prev_stack, parent_blk], 
         new_stack = prev_stack,  ((!longBlock(parent_blk), to_blk = parent_blk);
         (longBlock(parent_blk), !not_first_store(to_blk, sid, parent_blk), store_block(to_blk, parent, sid))),
         (
            (
                block_modifies_sv(to_blk, field, state_dep, arg_dep, sndr_dep),        
                arg_taint_dep = arg_dep band args_tainted,
                sv_taint_dep = state_dep band sv_tainted,
                is_sv_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_dep,
                (
                    (is_sv_val_taint != 0, sv_bv(bv, field), final_state = bv bor sv_tainted);
                    (is_sv_val_taint = 0, sv_bv(bv, field), final_state = (bnot bv) band sv_tainted)
                )
            );
            // block does not modify sv 
            (
                !doesModify(to_blk), final_state = sv_tainted
            )
         ), currhist = cat(cat(prehist, "-R->"), to_blk),
         hs < 14.

// Return argument transfer
// TODO (done): For Lukas, can u please set up implicit taint for return values (similar to how I did the jump see 509 transition) 
program_run(executed_blks, sv_tainted, final_arg_state, state, idx, hs, stack, prehist) :- 
        program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist),   // 00010   clean it --> 00001 but this DOES NOT MEAN 00010 is gone
        executed_blks = [prev_exec, last_blk], return(_, last_blk), stack = [prev_stack, possible_parent_blk], 
        ((longBlock(possible_parent_blk), first_mini_blk(possible_parent_blk, to_blk));(!longBlock(possible_parent_blk), to_blk = possible_parent_blk))
        ,arg_flow(arg, id_val, idx, last_blk, to_blk),
        idx = last_arg+1 ,ssa_depens_complete(id_val, args_val, sv_val, sndr_val, cnt_val),
        
        arg_taint_dep = args_val band args_tainted,
        sv_taint_dep = sv_val band sv_tainted,
        is_id_val_taint = (arg_taint_dep bor sv_taint_dep) bor sndr_val,        
        
        is_non_const = args_val bor sv_val,
        is_imp_tainted = state band 1,
        should_be_imp_tainted = is_imp_tainted band is_non_const,
        (
            (
                should_be_imp_tainted != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted
            );
            (   
                should_be_imp_tainted = 0,
                ((is_id_val_taint != 0, arg_bv(bv, arg), final_arg_state = bv bor args_tainted);
                (is_id_val_taint = 0, arg_bv(bv, arg), final_arg_state = args_tainted))
            )
        ).


//  ******************* END: JUMP LOGIC  *******************


// ******************* START: FUNCTION EXECUTION FINISHED *******************

.decl hasSelfDestruct(blk: Block)
hasSelfDestruct(blk) :- statement(stmt), blockStmt(blk, stmt), selfdestruct(stmt, _).


// return to argument setup block (from normal return). NB: the arguments are reset as untainted
program_run([executed_blks, to_blk], sv_tainted, 0, 0, -1, hs+1, stack, currhist) :- 
    program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist), 
    executed_blks = [prev_exec, last_blk], return(_, last_blk), stack = nil,
    (
        (arg_setup_blk(to_blk), state < 2); // only go the block which sets up user taint if we are not the admin user
        (
            state = 2, !hasSelfDestruct(last_blk),
            (
                (first_mini_blk(parent, to_blk), function(parent, _));
                (!longBlock(to_blk), function(to_blk, _))
            )
        )
    ), 
    currhist = cat(cat(prehist, "=>"), to_blk),
    hs < 14. 

// return to argument setup block (from revert). NB: the arguments are reset as untainted
program_run([executed_blks, to_blk], 0, 0, 0, -1, hs+1, nil, currhist) :- 
    program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist), 
    executed_blks = [prev_exec, last_blk], revert(_, last_blk),
    arg_setup_blk(to_blk), 
    currhist = cat(cat(prehist, "=>"), to_blk),
    state < 2,    
    hs < 14. 

// return to privileged user from unprivileged user return (privileged user does not introduce user input taint -> no need for arg_setup_blk)
program_run([executed_blks, to_blk], sv_tainted, 0, 2, -1, hs+1, nil, currhist) :- 
    program_run(executed_blks, sv_tainted, args_tainted, state, last_arg, hs, stack, prehist), 
    executed_blks = [prev_exec, last_blk], return(_, last_blk), stack = nil,
    function(parent_blk, x), x != "Constructor",  
    (
        (!longBlock(parent_blk), to_blk = parent_blk);
        (longBlock(parent_blk), !not_first_store(to_blk, _, parent_blk), store_block(to_blk, parent, _))
    ),
    currhist = cat(cat(prehist, "=>"), to_blk),
    state < 2,
    hs > 1, hs < 14. 

// setup arguments inside argument setup block
program_run(executed_blks, sv_tainted, args_tainted bor arg_taint, 0, idx, hs, stack, prehist) :- 
    program_run(executed_blks, sv_tainted, args_tainted, 0, last_arg, hs, stack, prehist), 
    executed_blks = [prev_exec, last_blk], arg_setup_blk(last_blk),  // if you append new history here, this rule will run forever and program will crash
    argument(id, substr(last_blk, 3, strlen(last_blk)),idx), idx=last_arg+1, arg_bv(arg_taint, id),  // no need to worry about the case where there is no arguments 
    hs < 14. 

// ******************* END: FUNCTION EXECUTION FINISHED *******************


// ******************* START: SELFDESTRUCT LOGIC *******************
.decl debug_info(executed_blks: BlkList, sv_state: number, arg_state: number, guarded: number, la : number, hist_size: number, stack: BlkList, string_hist: symbol)
//debug_info(executed_blks, sv_tainted, args_tainted, state, hs,stack, hist) :- program_run(executed_blks, sv_tainted, args_tainted, state, hs,stack, hist), state = 2.


// TODO: check also for state 3 (privileged but antiguarded)
tainted_sinks(id), debug_info(executed_blks, sv_tainted, args_tainted, state, la, hs,stack, hist) :-selfdestruct(id, addr), program_run(executed_blks, sv_tainted, args_tainted, state, la, hs,stack, hist), blockStmt(last_blk, id),
                    executed_blks = [prev_blks, last_blk], ssa_depens_complete(addr, args_dep, sv_dep, sndr, cnt), 
                    has_tainted_arg = args_dep band args_tainted, has_tainted_sv = sv_dep band sv_tainted, 
                    (
                        (is_tainted = has_tainted_arg bor has_tainted_sv bor sndr,(state=0; state=1));
                        (is_tainted = has_tainted_arg bor has_tainted_sv, state = 2)
                    ),
                    is_tainted != 0.

//.output debug_info
//.output program_run
.output tainted_sinks
//.output blockFollows
//.output arg_setup_blk
/*.output blockDominates
.output blockFollows
.output hasGuardSSA
.output unguardedTaintedSSA
.output guardSSA
.output taintedSSA
.output taintedStorage
.output context
.output fields
*/
