#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA)  // `var_cond_id` references the condition

// Jump from a block `id_block_from` to a different function with entry block
// `id_block_to` (i.e. a function call). The called function returns to the
// continuation block `id_continuation` of the caller function via return
// transfers.
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)

// Return transfer (note there is no target block; if needed, this can be
// inferred at call sites via the `id_continuation` of the jump transfer).
.decl return(id_transfer: Transfer, id_block_from: Block)

// List of arguments passed in a transfer
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)

// Ignore these...
//.decl arrayStore(id: SSA, id_array: SSA, id_index: SSA, id_var: SSA)
//.decl mapStore(id: SSA, id_map: SSA, id_key: SSA, id_var: SSA)
//.decl arrayLoad(id: SSA, id_array: SSA, id_index: SSA)
//.decl mapLoad(id: SSA, id_map: SSA, id_key: SSA)
//.decl call(id_transfer: Transfer, id_block_from: Block, id_block_to: Block, id_continuation: Block)
//.decl unknownBlock(id_block: Block)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

#ifdef ENABLE_INPUT_FROM_FILES
.input function
.input block
.input blockStmt
.input follows
.input argument
.input statement
.input assign
.input const
.input uop
.input bop
.input load
.input structLoad
.input store
.input structStore
.input goto
.input branch
.input return
.input jump
.input transferArgument
.input selfdestruct
.input revert
.input builtinVariable
// Ignore these...
//.input arrayLoad
//.input mapLoad
//.input arrayStore
//.input mapStore
//.input call
//.input unknownBlock
#endif


// Helper relations
.decl msgSender(id: SSA)
msgSender(id) :- builtinVariable(id, "SENDER").

// -- output relations --
.decl tainted_sinks(id: SSA)

// Your code goes here...

.decl blockFollows(id_block_from: Block, id_block_to: Block)
// There is a follows relation b/w blocks in case of 1: goto 2: branch 3: jump 
blockFollows(id_block_from, id_block_to) :- goto(_, id_block_from, id_block_to).
blockFollows(id_block_from, id_block_to) :-  branch(_, _, id_block_from, id_block_to, _, _); 
                                             branch(_, _, id_block_from, _, id_block_to, _).
blockFollows(id_block_from, id_block_to) :- jump(_,id_block_from, id_block_to,_); 
                                            jump(_,_,id_block_from, id_block_to). 

// Transitive closure (blockFollows is only for single hops)
.decl blockFollowsTransitive(id_block_from: Block, id_block_to: Block) 
blockFollowsTransitive(from, to) :- blockFollows(from, to). 
blockFollowsTransitive(from, to) :- blockFollowsTransitive(from, mid), blockFollows(mid, to).

// Dominance relation between blocks
.decl notDominates(top: Block, bottom: Block)
notDominates(top, bottom) :- notDominates(top, mid), blockFollows(mid, bottom), bottom != top.
notDominates(top, bottom) :- block(top), block(bottom), top != bottom, !blockFollowsTransitive(top, bottom).
notDominates(top, bottom) :- blockFollows(mid, bottom), blockFollows(mid, top), bottom != top.

.decl blockDominates(id_block_top: Block, id_block_bottom: Block)
blockDominates(top, bottom) :- block(top), block(bottom), top != bottom, !notDominates(top, bottom).

// If a block is a guard
.decl guardSSA(id: SSA)
.decl hasGuardSSA(block: Block)
.decl taintedSSA(id: SSA)
.decl taintedStorage(field: Name)


// Helper relation listing all fields
.decl fields(field: Name)
fields(field) :- load(_, field).
fields(field) :- store(_, field, _).


//.decl constructorBlock(block: Block)
//constructorBlock(block) :- function(block, "Constructor").

.type BlkList = [next: BlkList, blk: Block]
.type storageState = [varId: Name, valtype: symbol] // source can be "const", "arg"
.type storageStateList = [next: storageStateList, head: storageState] // should have length nbr of state variables


.decl startBlock(blk: Block) // blocks that are the start of functions, constructors
.decl context(depth: number, history: BlkList)
.decl storeHistory(history: BlkList, storedState: storageStateList, blockDepth: number)
.decl initial_stored_state(stored_state: storageStateList, cnt_state_vars: number)
.decl countStateVariables(cnt: number)

// nbr of state variables
countStateVariables(c) :- c = count:{fields(_)}.

/*.type IntList = [next: IntList, x: number]
.decl L(l: IntList)
L([nil,10]).
L([r1,x+10]) :- L(r1), r1=[r2,x], x < 30.
.decl Flatten(x: number)
Flatten(x) :- L([_,x]).
.output L*/


// base cases for store history
initial_stored_state(nil, 0).    // a fact (with zero state variables, the list of states is nil)
initial_stored_state([storage_state_prev_list, [new_head, "const"]], x+1) :- initial_stored_state(storage_state_prev_list, x),  // now deconstruct  storageStatePrev
                                           ((storage_state_prev_list = [s, [prev_head, "const"]],
                                           ord(new_head) > ord(prev_head)); x=0), 
                                           fields(new_head), // everything is constant at the beginning
                                           countStateVariables(c), x < c. 
.output initial_stored_state
.output countStateVariables
/*startBlock(blk) :- function(blk, _). 
storeHistory(blklist, stored_state, block_depth) :- block_depth = 0, function(blk, "Constructor"), blklist = [nil, blk], stored_state =[nil,].
storeHistory(blklist, stored_state, block_depth) :- block_depth = 1, startBlock(blk),
                                                    function(blk, fname), fname != "Constructor",
                                                    blklist = [[nil, "Constructor"], blk].
storeHistory(blklist, stored_state, block_depth + 1) :- storeHistory() 
*/



//context(0, [nil, blk]) :- block(blk).
//context(size+1, [hist, blk]) :- context(size, hist), block(blk), size < 2.


//initStorage([nil, [fiedlId, "cosnt"]]) :-  function(/..), field(fiedlId) 


//initStorage([nil, [field, valType]]) :- constructor(..), field(fieldId)
//initStorage(newLIst) :- initStorage(field), field = [nil, [field, valType]], newList = [, []]


// context(size, hist) :- context(size-1, hist), size < 3.


// 
.decl isMsgSender(id: SSA)
isMsgSender(id) :-  builtinVariable(id, "SENDER").
isMsgSender(id) :-  assign(id, orig), isMsgSender(orig).

// not tainted if it is a statement derived from another statement, which is itself untainted
taintedSSA(id) :- assign(id, orig), taintedSSA(orig).
taintedSSA(id) :- load(id, field), taintedStorage(field). 
taintedSSA(id) :- assign(id, orig), match("A.*", orig).
// not tainted if statement is the value of a state variable 

// tainted storage if it is assigned anything (over approximating for now. TODO: fix this to not over approx)
taintedStorage(field) :- store(_, field, id_from), taintedSSA(id_from).
taintedStorage(field) :- store(_, field, id_from), (match("A.*", id_from); taintedSSA(id_from)).


// id is the id of the SSA of the condition on which the branch bifurcates
guardSSA(id) :- branch(_, _, _, _, _, id), bop(id, id_lhs, id_rhs, _), 
                ( 
                    (isMsgSender(id_lhs), !taintedSSA(id_rhs));
                    (isMsgSender(id_rhs), !taintedSSA(id_lhs))
                ).

hasGuardSSA(block) :- guardSSA(id), blockStmt(block, id).

.decl unguardedTaintedSSA(id: SSA)
.decl unguardedTaintedStorage(field: Name)

unguardedTaintedSSA(id) :- taintedSSA(id), blockStmt(block, id), !hasGuardSSA(block).
unguardedTaintedStorage(field) :- taintedStorage(field), store(id, field, _), blockStmt(block, id), !hasGuardSSA(block). 



tainted_sinks(id) :- selfdestruct(id, address).

.output tainted_sinks
.output blockDominates
.output blockFollows
.output blockFollowsTransitive
.output notDominates
.output hasGuardSSA
.output unguardedTaintedSSA
.output guardSSA
.output taintedSSA
.output taintedStorage
.output context
.output fields