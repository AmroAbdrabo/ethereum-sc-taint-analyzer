#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA) 
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)
.decl return(id_transfer: Transfer, id_block_from: Block)
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

// -- output relations --
.decl tainted_sinks(id: SSA)

// Useful (wallah)
.decl msgSender(id: SSA)
msgSender(id) :-  builtinVariable(id, "SENDER").
msgSender(id) :-  assign(id, orig), msgSender(orig).

// Encode each state variable as a one-hot vector
// (assuming there are 3 state variables) 100 for the first variables
// 000 means all state variables are untainted, 100 means only first 
// field, V00, is tainted
.decl activate_taint(state: unsigned, field: Name)

// These inputs are generated/written by Python
activate_taint(1, "V00").
activate_taint(2, "V01").
activate_taint(4, "V02").

.decl deactivate_taint(state: unsigned, field: Name) 
// Unfortunately we only need 3 bits but datalog gives us 32 hence the need for 
// 0b111 mask (i.e. 7)
deactivate_taint((bnot tainted) band 7, field) :- activate_taint(tainted, field).
// NB: 7 will be generated/written by python 

.type BlkList = [next: BlkList, blk: Block]
.decl program_run(executed_blks: BlkList, final_state: unsigned, guarded: unsigned) // final state after executing blklist

// Now we make a relation block_taints_state_variable which contains
// records of the form B02, 101 meaning that inside B02 there is a store of user input
// (including msg.sender) to V00 and V02

// blk is the block, tainted_fields are the fields which are assigned user input inside 
// blk, and cnt is the number of tainted variables taken into account by the relation
.decl block_taints_state_variables(blk: Block, tainted_fields: unsigned, cnt : unsigned)
block_taints_state_variables(blk, tainted_fields, 1) :- store(stmt, field, assigned),
  blockStmt(blk, stmt), activate_taint(tainted_fields, field), 
  (argument(assigned, _, _); msgSender(assigned)).

// Combine taints for a block
block_taints_state_variables(blk, (tainted_fields_first bor tainted_fields_second) band 7, cnt1 + cnt2) :- 
  block_taints_state_variables(blk, tainted_fields_first, cnt1),
  block_taints_state_variables(blk, tainted_fields_second, cnt2),
  cnt1+ cnt2 < 3. // Again, 3 and 7 should be generated/written by python

// Unfortunately, at this point we still have a lot of relations for block_taints_state_variable 
// of the form (blk, 110, 2) and (blk, 100, 1) but we only care about the one maximum cnt so we say (souffle 
// does not allow witnesses for maximum so we have to create a new relation)
.decl block_taints_not_complete(blk: Block, tainted_fields: unsigned, cnt: unsigned)
block_taints_not_complete(blk, tainted_fields, cnt) :- block_taints_state_variables(blk, tainted_fields, cnt),
  		block_taints_state_variables(blk, tainted_fields2, cnt2), cnt2 > cnt.
.decl block_taints_complete(blk: Block, tainted_fields: unsigned, cnt: unsigned)

// A block taints (completely) if there is no example where it is a minimum (in terms of cnt).
block_taints_complete(blk, tainted_fields, cnt) :- block(blk), 
  												   block_taints_state_variables(blk, tainted_fields, cnt),
  												  !block_taints_not_complete(blk, tainted_fields, cnt).

.decl block_taints_noth(blk: Block)
block_taints_noth(blk) :- block(blk), !block_taints_complete(blk, _, _).

// Helpher function: check if something is (in)directly an argument
.decl user_input(id: SSA)
user_input(id) :- argument(id,_,_).
user_input(id) :- assign(id, orig), user_input(orig).

// Transitively close constants
const(id, value) :- assign(id, orig), const(orig, value).
// Transitively close load
load(id, field) :-  assign(id, orig), load(orig, field).
// Either const or msg.sender (the safe values in a require)
.decl cnst_or_sender(stmt: SSA)
cnst_or_sender(stmt) :- const(stmt, _); msgSender(stmt).

// we consider a (later guard) condition to be safe if it does not depend on user provided arguments. However, we keep
// track of which state variables it depends on.
.decl safe_condition(stmt: SSA, state_variables: unsigned)
// condition is const op const
safe_condition(stmt, 0) :- bop(stmt, lhs, rhs,_), cnst_or_sender(lhs), cnst_or_sender(rhs).
// load op const
safe_condition(stmt, tvec) :- bop(stmt, lhs, rhs,_), load(lhs, field), cnst_or_sender(rhs), activate_taint(tvec, field).
// const op load
safe_condition(stmt, tvec) :- bop(stmt, lhs, rhs,_), load(rhs, field), cnst_or_sender(lhs), activate_taint(tvec, field).
// load op load
safe_condition(stmt, tvec1 bor tvec2) :- bop(stmt, lhs, rhs,_), load(rhs,field1), 
  											load(lhs,field2), activate_taint(tvec1, field1), activate_taint(tvec2, field2).

// cond op cond
safe_condition(stmt, tvec1 bor tvec2) :- bop(stmt, lhs, rhs,_), safe_condition(rhs,tvec1), 
  											safe_condition(lhs, tvec2).

// cond op const
// const op cond
safe_condition(stmt, tvec) :- bop(stmt, lhs, rhs,_),(
  												(
                                                  safe_condition(rhs, tvec), 
                                                  cnst_or_sender(lhs)
                                                ); 
                                                (
                                                    safe_condition(lhs, tvec), 
                                                    cnst_or_sender(rhs)
                                                )
                                            ).

// cond op load
// load op cond
safe_condition(stmt, tvec1 bor tvec2) :- bop(stmt, lhs, rhs,_),(
  												(
                                                  safe_condition(rhs, tvec1), 
                                                  load(lhs, field2), activate_taint(tvec2, field2)
                                                ); 
                                                (
                                                  safe_condition(lhs, tvec1), 
                                                  load(rhs, field2), activate_taint(tvec2, field2)
                                                )
                                            ).
                                            
// Same as safe_condition but we only care about those which produce a branching
.decl safe_guard_condition(stmt: SSA, state_variables: unsigned)
safe_guard_condition(stmt, state_variables) :- safe_condition(stmt, state_variables), branch(_,_, _,_,_, stmt).

.decl safe_guarded_block(blk: Block, state_variables: unsigned)
safe_guarded_block(blk, state_variables) :- safe_guard_condition(stmt, state_variables), blockStmt(blk,stmt).

.decl unguarded_block(blk: Block)
unguarded_block(blk) :- block(blk), !safe_guarded_block(blk, _).

// Simulate program run
// final_state is the state of all state variables at end of execution

// ********************* PROGRAM LOGIC *********************
/* After executing executed_blks, we now execute current_block. We now do a case-by-case study depending on 
 * two factors: whether there is a guard after execution of executed_blks, and whether the current block contains a guard
 *
 * CASE 1 (Guard in executed_blks): regardless of what current_blk is, the execution is still guarded (of course, it
 * is still possible that there is a execution flow which ends in current_blk and is unguarded. Relation program_run 
 * merely expresses the state after a sequence of blocks, not the absolute state of a single block).
If current_block is not guarded, it inherits the guarded 
 * state from the end of exeuction of list_blks. If current_block is guarded, then program_run's state after execution 
 * of [executed_blks, current_block] is guarded (i.e. guarded=1)
*/

/*program_run([executed_blks, current_block], next_state bor hot_taint_vector, guarded) :- 
  						program_run(executed_blks, current_state),
  						block_taints_state_variables(current_block, taint_vector), 
  						activate_taint(hot_taint_vector, var_id)

*/


tainted_sinks(id) :- selfdestruct(id, _).


.output deactivate_taint
.output tainted_sinks

/*.output blockDominates
.output blockFollows
.output blockFollowsTransitive
.output notDominates
.output hasGuardSSA
.output unguardedTaintedSSA
.output guardSSA
.output taintedSSA
.output taintedStorage
.output context
.output fields
*/